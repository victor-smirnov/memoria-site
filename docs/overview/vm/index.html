<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://memoria-framework.dev/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://memoria-framework.dev/main.4aee7b9c653a9441aeccbab4bf9a20bb4827ed71a21077328be36d74cbe63081492792ee312478e64d73f5e762a2ad3c04431ecfa8d16da63373639763e86b0c.css integrity="sha512-Su57nGU6lEGuzLq0v5ogu0gn7XGiEHcyi+NtdMvmMIFJJ5LuMSR45k1z9edioq08BEMez6jRbaYzc2OXY+hrDA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>DSL Engine - Memoria</title><meta name=description content><link rel=canonical href=https://memoria-framework.dev/docs/overview/vm/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="DSL Engine"><meta property="og:description" content="Introduction Historically, Memoria was meant to be a storage engine, leaving data processing aspects to applications. After trying Memoria in various projects involving C++ and Java it was clear that it&rsquo;s not a good idea. To be used at its full potential, Memoria requires its own runtime environment. Bridging different runtimes like C++ with fibers and JVM is a close to impossible task, if efficiency is a goal. After experiments with PrestoDB on top of Memoria and development of String Data Notation format, recently superseded by Hermes, it became clear that Memoria needs its own integrated query execution engine."><meta property="og:url" content="https://memoria-framework.dev/docs/overview/vm/"><meta property="og:site_name" content="Memoria"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="DSL Engine"><meta name=twitter:description content><meta name=twitter:card content="summary"><meta name=twitter:image:alt content="DSL Engine"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://memoria-framework.dev/#/schema/person/1","name":"Memoria","url":"https://memoria-framework.dev/","sameAs":[],"image":{"@type":"ImageObject","@id":"https://memoria-framework.dev/#/schema/image/1","url":"https://memoria-framework.dev/\u003cnil\u003e","width":null,"height":null,"caption":"Memoria"}},{"@type":"WebSite","@id":"https://memoria-framework.dev/#/schema/website/1","url":"https://memoria-framework.dev/","name":"Memoria","description":"","publisher":{"@id":"https://memoria-framework.dev/#/schema/person/1"}},{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/overview/vm/","url":"https://memoria-framework.dev/docs/overview/vm/","name":"DSL Engine","description":"","isPartOf":{"@id":"https://memoria-framework.dev/#/schema/website/1"},"about":{"@id":"https://memoria-framework.dev/#/schema/person/1"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","breadcrumb":{"@id":"https://memoria-framework.dev/docs/overview/vm/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://memoria-framework.dev/docs/overview/vm/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://memoria-framework.dev/docs/overview/vm/"]}]},{"@type":"BreadcrumbList","@id":"https://memoria-framework.dev/docs/overview/vm/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/","url":"https://memoria-framework.dev/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/","url":"https://memoria-framework.dev/docs/","name":"Docs"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/overview/","url":"https://memoria-framework.dev/docs/overview/","name":"Overview"}},{"@type":"ListItem","position":4,"item":{"@id":"https://memoria-framework.dev/docs/overview/vm/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://memoria-framework.dev/#/schema/article/1","headline":"DSL Engine","description":"","isPartOf":{"@id":"https://memoria-framework.dev/docs/overview/vm/"},"mainEntityOfPage":{"@id":"https://memoria-framework.dev/docs/overview/vm/"},"datePublished":"0001-01-01T00:00:00CET","dateModified":"0001-01-01T00:00:00CET","author":{"@id":"https://memoria-framework.dev/#/schema/person/2"},"publisher":{"@id":"https://memoria-framework.dev/#/schema/person/1"},"image":{"@id":"https://memoria-framework.dev/docs/overview/vm/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://memoria-framework.dev/#/schema/person/2","name":"Victor Smirnov","sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://memoria-framework.dev/docs/overview/vm/#/schema/image/2","url":null,"contentUrl":null,"caption":"DSL Engine"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://memoria-framework.dev/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://memoria-framework.dev/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://memoria-framework.dev/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://memoria-framework.dev/site.webmanifest></head><body class="docs single"><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=Memoria>Memoria</a>
<button class="btn btn-menu d-block d-md-none order-5" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-start border-0 py-md-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-md-none"></div><div class="offcanvas-header d-md-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>Memoria</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body px-4"><h3 class="h6 text-uppercase mb-3 d-md-none">Main</h3><ul class="nav flex-column flex-md-row ms-md-n3"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/docs/overview/introduction/>Docs</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/subprojects/overview/>Subprojects</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/issues>Issues</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/discussions>Discussions</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/wiki>Releases</a></li></ul><hr class="text-black-50 my-4 d-md-none"><h3 class="h6 text-uppercase mb-3 d-md-none">Socials</h3><ul class="nav flex-column flex-md-row ms-md-auto me-md-n5 pe-md-2"><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-md-none">GitHub</small></a></li></ul></div></div></nav></header><nav class="doks-subnavbar py-2 sticky-lg-top" aria-label="Secondary navigation"><div class="container-xxl d-flex align-items-md-center"><form class="doks-search position-relative flex-grow-1 me-auto"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><button class="btn doks-sidebar-toggle d-lg-none ms-3 order-3 collapsed" type=button data-bs-toggle=collapse data-bs-target=#doks-docs-nav aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle documentation navigation"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></button></div></nav><div class=container-xxl><aside class=doks-sidebar><nav id=doks-docs-nav class="collapse d-lg-none" aria-label="Tertiary navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-overview aria-expanded=true>
Overview</button><div class="collapse show" id=section-overview><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/overview/introduction/>Introduction to Memoria</a></li><li><a class="docs-link rounded" href=/docs/overview/philosophy/>Philosophy</a></li><li><a class="docs-link rounded" href=/docs/overview/hermes/>Hermes</a></li><li><a class="docs-link rounded" href=/docs/overview/hrpc/>HRPC: Hermes RPC Protocol</a></li><li><a class="docs-link rounded" href=/docs/overview/containers/>Containers</a></li><li><a class="docs-link rounded" href=/docs/overview/storage/>Storage Engines</a></li><li><a class="docs-link rounded" href=/docs/overview/runtime/>Runtime Environments</a></li><li><a class="docs-link rounded active" href=/docs/overview/vm/>DSL Engine</a></li><li><a class="docs-link rounded" href=/docs/overview/accel/>Memoria Acceleration Architecture (MAA)</a></li><li><a class="docs-link rounded" href=/docs/overview/mbt/>Memoria Build Tool</a></li><li><a class="docs-link rounded" href=/docs/overview/qt_creator_instructions/>Qt Creator Instructions</a></li><li><a class="docs-link rounded" href=/docs/overview/roadmap/>Project Roadmap</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-datazoo aria-expanded=false>
Data Zoo</button><div class=collapse id=section-datazoo><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/data-zoo/overview/>Core Data Structures -- Overview</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/partial-sum-tree/>Partial Sums Tree</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/searchable-seq/>Searchable Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/compressed-symbol-seq/>Compressed Symbol Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/hierarchical-containers/>Hierarchical Containers</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/louds-tree/>Level Order Unary Degree Sequence (LOUDS)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/wavelet-tree/>Multiary Wavelet Trees</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/packed-allocator/>Packed Allocator</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-1/>Associative Memory (Part 1)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-2/>Associative Memory (Part 2)</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-apps aria-expanded=false>
Applications</button><div class=collapse id=section-apps><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/applications/aiml/>Hybrid AI</a></li><li><a class="docs-link rounded" href=/docs/applications/storage/>Computational Storage</a></li><li><a class="docs-link rounded" href=/docs/applications/db/>Converged Databases</a></li><li><a class="docs-link rounded" href=/docs/applications/co-design/>HW/SW Co-design</a></li><li><a class="docs-link rounded" href=/docs/applications/eiot/>Embedded and IoT Applications</a></li></ul></div></li></ul></nav></aside></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar d-none d-lg-block"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-overview aria-expanded=true>
Overview</button><div class="collapse show" id=section-overview><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/overview/introduction/>Introduction to Memoria</a></li><li><a class="docs-link rounded" href=/docs/overview/philosophy/>Philosophy</a></li><li><a class="docs-link rounded" href=/docs/overview/hermes/>Hermes</a></li><li><a class="docs-link rounded" href=/docs/overview/hrpc/>HRPC: Hermes RPC Protocol</a></li><li><a class="docs-link rounded" href=/docs/overview/containers/>Containers</a></li><li><a class="docs-link rounded" href=/docs/overview/storage/>Storage Engines</a></li><li><a class="docs-link rounded" href=/docs/overview/runtime/>Runtime Environments</a></li><li><a class="docs-link rounded active" href=/docs/overview/vm/>DSL Engine</a></li><li><a class="docs-link rounded" href=/docs/overview/accel/>Memoria Acceleration Architecture (MAA)</a></li><li><a class="docs-link rounded" href=/docs/overview/mbt/>Memoria Build Tool</a></li><li><a class="docs-link rounded" href=/docs/overview/qt_creator_instructions/>Qt Creator Instructions</a></li><li><a class="docs-link rounded" href=/docs/overview/roadmap/>Project Roadmap</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-datazoo aria-expanded=false>
Data Zoo</button><div class=collapse id=section-datazoo><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/data-zoo/overview/>Core Data Structures -- Overview</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/partial-sum-tree/>Partial Sums Tree</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/searchable-seq/>Searchable Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/compressed-symbol-seq/>Compressed Symbol Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/hierarchical-containers/>Hierarchical Containers</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/louds-tree/>Level Order Unary Degree Sequence (LOUDS)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/wavelet-tree/>Multiary Wavelet Trees</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/packed-allocator/>Packed Allocator</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-1/>Associative Memory (Part 1)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-2/>Associative Memory (Part 2)</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-apps aria-expanded=false>
Applications</button><div class=collapse id=section-apps><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/applications/aiml/>Hybrid AI</a></li><li><a class="docs-link rounded" href=/docs/applications/storage/>Computational Storage</a></li><li><a class="docs-link rounded" href=/docs/applications/db/>Converged Databases</a></li><li><a class="docs-link rounded" href=/docs/applications/co-design/>HW/SW Co-design</a></li><li><a class="docs-link rounded" href=/docs/applications/eiot/>Embedded and IoT Applications</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#related-c-with-homoiconic-compile-time-metaprogramming>Related: C++ with homoiconic compile-time metaprogramming</a></li><li><a href=#what>What</a><ul><li><a href=#m-code-and-code-model>M-code and Code Model</a></li><li><a href=#native-hermes-integration>Native Hermes integration</a></li><li><a href=#compile-time-metaprogramming>Compile-time metaprogramming</a></li><li><a href=#rule-engine>Rule Engine</a></li></ul></li><li><a href=#language-kit>Language Kit</a></li><li><a href=#roadmap>Roadmap</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>DSL Engine</h1><p class=lead></p><nav class=d-xl-none aria-label="Quaternary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#related-c-with-homoiconic-compile-time-metaprogramming>Related: C++ with homoiconic compile-time metaprogramming</a></li><li><a href=#what>What</a><ul><li><a href=#m-code-and-code-model>M-code and Code Model</a></li><li><a href=#native-hermes-integration>Native Hermes integration</a></li><li><a href=#compile-time-metaprogramming>Compile-time metaprogramming</a></li><li><a href=#rule-engine>Rule Engine</a></li></ul></li><li><a href=#language-kit>Language Kit</a></li><li><a href=#roadmap>Roadmap</a></li></ul></nav></div></nav><h2 id=introduction>Introduction<a href=#introduction class=anchor aria-hidden=true>#</a></h2><p>Historically, Memoria was meant to be a <em>storage engine</em>, leaving data processing aspects to applications. After trying Memoria in various projects involving C++ and Java it was clear that it&rsquo;s not a good idea. To be used at its full potential, Memoria requires its own runtime environment. Bridging different runtimes like C++ with fibers and JVM is a close to impossible task, if efficiency is a goal. After experiments with PrestoDB on top of Memoria and development of String Data Notation format, recently superseded by <a href=/docs/overview/hermes/>Hermes</a>, it became clear that Memoria needs its own integrated <em>query execution engine</em>. And the technical challenge is that today&rsquo;s and perspective <em>query languages</em> have evolved from non-Turing-complete DSLs into fully featured <em>programming languages</em>, even with capabilities of <a href=https://en.wikipedia.org/wiki/Programming_in_the_large_and_programming_in_the_small>programming in the large</a>. So designing and building a kind of an SQL query execution engine (a pretty complex beast by itself, actually) would not be sufficient, given the project&rsquo;s long-term goals. Instead, we need a generic virtual machine, heavily tuned for various query languages.</p><h2 id=related-c-with-homoiconic-compile-time-metaprogramming>Related: C++ with homoiconic compile-time metaprogramming<a href=#related-c-with-homoiconic-compile-time-metaprogramming class=anchor aria-hidden=true>#</a></h2><p>The early experiment on this ground was an <a href=https://github.com/victor-smirnov/jenny>attempt</a> to use C++ as a DSL host language by adding of a full C++ subset as a compile-time metaprogramming language into the Clang compiler. Clang is a modular and well-engineered compiler, it even can run full set of C++ in a JIT mode. Internally Clang is more like a data platform with databases and clear separation to <em>storage</em> and <em>compute</em>. Currently this experiment is on pause, we need to wait and see where evolution of C++ will go. There is substantial interest around C++ <a href=https://thenewstack.io/googles-carbon-among-other-potential-c-successors/>successor languages</a> like Carbon and Cpp2/Cppfront. In addition, there is an ongoing tectonic shift in conventional commercial and opensource programming right now, induced by LLM-powered <em>automatic programming</em>. Old rationales (1960-70th) do not apply anymore, programming languages of tomorrow may look completely different in terms of focus and leading paradigms.</p><h2 id=what>What<a href=#what class=anchor aria-hidden=true>#</a></h2><p>In/for Memoria we do not try to create a new general purpose <em>system</em> language <em>competing</em> with C++ or any its successor languages. Instead, we need a highly compatible <em>companion</em> language for domains where <a href=https://en.wikipedia.org/wiki/Kolmogorov_complexity>descriptional complexity</a> is very high, so &ldquo;<em>code is a new data</em>&rdquo;.</p><p>Here is how Memoria is going to fit this niche. There are five key features:</p><ol><li>Memoria defines bytecode-like extensible intermediate-level <em>M-code</em> and <a href=/docs/overview/hermes/>Hermes</a>-backed <em>Code Model</em>. M-code is low-level enough to be long-term stable and suitable for <em>tooling</em> (static analyzers, etc), but high-level enough to make writing DSLs simpler.</li><li>Native <a href=/docs/overview/hermes/>Hermes</a> integration. Hermes datatypes, objects and containers are distinct but first-class elements of the language.</li><li>Rich embedded metadata. Elements in the <em>code model</em> may have arbitrary Hermes metadata (annotations) associated with them.</li><li>Homoiconic compile-time metaprogramming and supporting <em>metaprogramming platform</em>, integrated with runtime environment and the interpreter.</li><li>RETE-based rule engine for advanced pattern matching.</li></ol><p>M-code and related infrastructure are targeting the <strong>in-database programming</strong> problem.</p><p>General-purpose programming languages are targeting <em>compute-intensive</em> problems that use rather simple data structures: arrays and linked data structures like object graphs. Data structures are simple and ephemeral.</p><h3 id=m-code-and-code-model>M-code and Code Model<a href=#m-code-and-code-model class=anchor aria-hidden=true>#</a></h3><p>Memoria does not introduce any new high-level programming language, like Java or Python. Instead, it defines intermediate-level <em>DSL Host</em> language M-code. M-code may have two forms:</p><ol><li>Textual, where it looks somewhat like assembly code: classes, functions, rules, <em>code blocks</em> and statements, metadata (something like MLIR code looks like).</li><li>Structured representation: all of these but in a dense memory-optimized Hermes documents.</li></ol><p>Like it&rsquo;s in high-level languages, there is no explicit access to the stack (no push/pop statements), but there no any <em>syntactic sugar</em>: just typed variable declarations, simple control flow (branches/cycles/exceptions) and function calls.</p><p>M-code may use pretty large subset of normalized C++ types, but internally represents them as 192-256-bit hash codes, taken from a normalized type declaration. Collisions at this level are treated as insignificantly rare. Fixed-size type name encoding simplifies and speeds up the code model significantly.</p><p>This design of M-code pursues two main goals:</p><ol><li>M-code allows efficient <em>lowering</em> to C++ (or any other suitable underling language like Rust, Carbon, Mojo or MLIR/LLVM), by using mostly local transformations: each statement of M-code becomes a statement of an underling language. Depending on the underling language, M-code program may have slightly different semantics. Perfect cross-language compatibility is <em>not</em> a goal.</li><li>Efficient (high-performance) but lightweight <em>embeddable</em> code interpreter, suitable for evaluating DSL expressions in a C++ code.</li></ol><p>So, M-code can be either:</p><ol><li>Interpreted,</li><li>AOT-transpiled to C++ (maybe by building the AST directly, without parsing texts),</li><li>JIT-compiled to MLIR/LLVM. Probably the best way to run database queries.</li></ol><p>1 and 2 is currently the priority.</p><p>M-code may call native C++ code, but the latter needs to be described in a <em>code registry</em>: function type, signature, physical address, other metadata. All this information (bindings) can be automatically generated using <a href=/docs/overview/mbt/>MBT</a>. Native code can also call M-code, but the syntax <em>may be</em> verbose (even for the AOT-compiled M-code).</p><p>M-code functions, classes, rules (see below), metadata, embedded resources are organized into modules, modules &ndash; into assemblies. Assemblies can be linked with executables in a read-only memory segments, assemblies are just Hermes documents. Assemblies can also be AOT-compiled into native code (libraries). This native code will run at the full speed of other Memoria code, and it will be transparently invokable from interpreted M-code.</p><p>M-code is meant to be memory/thread-safe and <em>UB-free</em> by default, but may support full unrestricted memory access in a special profile. The basic idea is simple: M-code is a <em>companion</em> (domain-specific) language to C++, so let&rsquo;s just move all high-performance but &lsquo;unsafe&rsquo; programming to C++. At the level of M-code safety is achieved by restricting the language and using run-time checks. There is no expectations that M-code, AOT-compiled to C++, will be faster than equivalent C++ code.</p><h3 id=native-hermes-integration>Native Hermes integration<a href=#native-hermes-integration class=anchor aria-hidden=true>#</a></h3><p>There are tree layers of integration:</p><ol><li><em>Object/data model</em> integration. Hermes objects are distinct but first class data objects. HRPC services are first class objects, supported by the runtime.</li><li><em>Language-level</em> integration. Think dict/list comprehension of python. M-code explicitly support code blocks that can be used to model array and map (and some other) containers of Hermes.</li><li><em>Code Model</em> integration. M-code assemblies are just Hermes documents, so any Hermes data can be embedded with the application and instantly available to the code. Like reflection data and code annotations.</li></ol><h3 id=compile-time-metaprogramming>Compile-time metaprogramming<a href=#compile-time-metaprogramming class=anchor aria-hidden=true>#</a></h3><p>C++ type-level template metaprogramming isn&rsquo;t that bad, actually. It does require <em>a lot</em> of attention every time we make a change to the meta-code, so it&rsquo;s a <em>high-maintenance</em> thing, but there is a lot of high-maintenance code here and there, so what&rsquo;s the issue? The issue is that <em>advanced</em> type-level metaprogramming is not needed in the industry. For systems programming language we need simple collections and class/function specialization, this is what C++ has been pretty good at.</p><p>C++ does need advanced <em>AST-level</em> metaprogramming, usually provided by hygienic procedural macro systems, but, again, for what? Embedding DSLs? OK. Boilerplate code generation (serialization, bindings, etc)? OK. We can use external code generators for that. It will be hard to find definitive example that may justify the need for <em>advanced metaprogramming</em>.</p><p>The point of Memoria, in this respect, is that multimodal databases do need advanced metaprogramming to craft data structures <em>optimized for applications' needs</em>. Databases in general benefit from metaprogramming, but usually they are isolated blackboxes, available via simplistic and inexpressive DSLs. General audience just doesn&rsquo;t know what&rsquo;s happening there. Memoria is trying to escape this historical trend by &lsquo;opening up&rsquo; and providing it&rsquo;s internals to application developers, and exposing them (developers) to high-complexity data modelling problems.</p><p>DSL Engine will be supporting compile-time metaprogramming at both type- and AST-levels. M-code interpreter is not actually an interpreter but a <em>dynamic compiler</em> paired with a <em>build system</em>. Metaprograms are just regular M-code, called at the compile-time, and can be AOT-compiled for better performance.</p><h3 id=rule-engine>Rule Engine<a href=#rule-engine class=anchor aria-hidden=true>#</a></h3><p>There are two strategies of query execution &ndash; <em>request-driven</em> and <em>data-driven</em>. In the first case we have a lot of data and a small number of complex queries. Query execution is usually initiated by an external actor (user or service). In the second case we have a lot of small queries and a small amount of quickly-changing data. And each time data is changed, relevant queries are re-evaluated automatically. If they update the data, the process continues until data updating stops. The first type is better known in the literature as <em>backward chaining</em> (BC) strategy of evaluation, the second one &ndash; as <em>forward chaining</em> strategy of evaluation (FC).</p><p>In general case, with BC we have some <em>goal</em> (a query) and we need to check what is aligned with this goal (filter the data according to the query). With FC strategy we have some <em>change</em> (event) and we need to compute what are <em>consequences</em> of this change. Regular request-response databases use BC strategy for query evaluation. There are two main examples of FC systems:</p><ol><li>Complex Event Processing or CEP.</li><li>Continuous Queries (CQ), or (better known as) Stream Processing (SP).</li></ol><p>CEP and CQ/SP target different use cases, they use different base algorithms. CEP may use a variant of RETE, that, basically, tries to find <em>patterns in data</em>. And patterns are described as a set of rules: <em>pattern</em>-><em>reaction</em>. The most prominent opensource implementation of this approach is <a href=https://www.drools.org/>Drools</a>.</p><p>Pattern-matching with RETE is pretty close to general data-flow (DF) programming, but more high-level (unlike plain DF, it has <code>join</code> operation). In this respect, conventional <em>control flow</em> (CF) programming is close to backward chaining external <em>control</em> is guiding the process to its <em>goal</em>. What is interesting about RETE is that it can be hardware-accelerated. RETE&rsquo;s Beta-nodes are just Cartesian product operations are similar to matrix multiplication and can be accelerated using the similar approach (<a href=https://en.wikipedia.org/wiki/Systolic_array>systolic arrays</a>). Moreover, RETE is well-extandable, there can be variants for probabilistic and approximate inference, hybridizing with neural networks and so on&mldr;</p><p>The goal of Memoria&rsquo;s DSL Engine is to provide <em>integrated</em> execution environment for backward chaining strategy (regular queries, CF programs) and forward chaining (RETE-based CEP and SP).</p><h2 id=language-kit>Language Kit<a href=#language-kit class=anchor aria-hidden=true>#</a></h2><p>M-code is an intermediate level language and is not intended for manual code authoring. For high-level languages and DSLs there is a Boost Spirit integration. The grammar may produce AST on a Hermes document format directly, without intermediate objects. This is how HermesPath and Hermes Template engine (Jinja-like syntax) works.</p><p>But Boost Spirit isn&rsquo;t that scalable, so there are plans to integrate ANTLR4 with Hermes. The idea is to write special ALTLR4 backend producing AST in the Hermes Document format and related helper classes.</p><h2 id=roadmap>Roadmap<a href=#roadmap class=anchor aria-hidden=true>#</a></h2><p>DSL Engine may look like it&rsquo;s a fully featured programming <em>platform</em>, but this specific part of the design is <em>highly experimental</em>. The goal is to support <em>DSL programming in the large</em>, with focus on advanced cases like first-class support for accelerated RETE inference engine.</p><p>DSL Engine is going to be detachable, configurable and embeddable, so other projects may also use it even if don&rsquo;t need the rest of Memoria and have different runtime environments.</p><div class="docs-navigation d-flex justify-content-between"><a href=/docs/overview/runtime/><div class="card my-1"><div class="card-body py-2">&larr; Runtime Environments</div></div></a><a class=ms-auto href=/docs/overview/accel/><div class="card my-1"><div class="card-body py-2">Memoria Acceleration Architecture (MAA) &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://www.github.com/>Github</a>, <a href=https://gohugo.io/>Hugo</a>, and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/privacy-policy/>Privacy</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.73ca27033146a505b6a0f66b79d99f613a18e778bc9606fd223476d0ebf0fc10508b0d4f5c448b0a946fa1d71fbeffaae9732adc0c2890e61c449217fd6ee1c0.js integrity="sha512-c8onAzFGpQW2oPZredmfYToY53i8lgb9IjR20Ovw/BBQiw1PXESLCpRvodcfvv+q6XMq3AwokOYcRJIX/W7hwA==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.c5b6bb65307e087bfc3dd5a73cf000f3dc6a8b665db8c3fcbd62a3368e2f82ee494fd1ff5f025a09216cf6390bac7565c5469c6958caac1b9d09c85ba0adfefc.js integrity="sha512-xba7ZTB+CHv8PdWnPPAA89xqi2ZduMP8vWKjNo4vgu5JT9H/XwJaCSFs9jkLrHVlxUacaVjKrBudCchboK3+/A==" crossorigin=anonymous defer></script>
<script src=/js/vendor/katex/dist/katex.min.07c5862e6eea64c90e601fcaacaa0dbdb03f60dbbac68a5a5830130a00332df28001a5fa2375b739426606b441725db1af012c7e4b04b8fb222025cc0d2ac073.js integrity="sha512-B8WGLm7qZMkOYB/KrKoNvbA/YNu6xopaWDATCgAzLfKAAaX6I3W3OUJmBrRBcl2xrwEsfksEuPsiICXMDSrAcw==" crossorigin=anonymous defer></script>
<script src=/js/vendor/katex/dist/contrib/auto-render.min.bc779bab10cdc862f139e7cd6255a8f021bc483db2b7bc6d553238fb220e937dbe5cd511100d2ab764ee5d9f9092a2cdcc4e6ae109966efc18338f0b275d927d.js integrity="sha512-vHebqxDNyGLxOefNYlWo8CG8SD2yt7xtVTI4+yIOk32+XNUREA0qt2TuXZ+QkqLNzE5q4QmWbvwYM48LJ12SfQ==" crossorigin=anonymous defer></script>
<script src=/main.min.56cf146845ee56429c57a9bb74bee52540a1aa942a32506ad0d185db760f2f7a5d76f39cde824735c8b7e89f2e4453cc4da383eaa2c2a7d6a2c9dafd7061e74d.js integrity="sha512-Vs8UaEXuVkKcV6m7dL7lJUChqpQqMlBq0NGF23YPL3pddvOc3oJHNci36J8uRFPMTaOD6qLCp9aiydr9cGHnTQ==" crossorigin=anonymous defer></script>
<script src=https://memoria-framework.dev/index.min.615ad3a9c9519ae7f812de41a23a798d3683f237b39efd311cd04dbfe06ea99d65e77ac0384ddb5033edf03e88db7a0d136037d73a601ae2966c032265784a58.js integrity="sha512-YVrTqclRmuf4Et5Bojp5jTaD8jeznv0xHNBNv+BuqZ1l53rAOE3bUDPt8D6I23oNE2A31zpgGuKWbAMiZXhKWA==" crossorigin=anonymous defer></script></body></html>