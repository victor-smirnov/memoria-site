<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Overview List on</title><link>https://memoria-framework.dev/docs/overview/</link><description>Recent content in Overview List on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:48:45 +0000</lastBuildDate><atom:link href="https://memoria-framework.dev/docs/overview/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Memoria</title><link>https://memoria-framework.dev/docs/overview/introduction/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/introduction/</guid><description>Data dominates. If you&amp;rsquo;ve chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.
&amp;ndash; Rob Pike in “Notes on Programming in C”, 1989.
How it started&amp;hellip; Memoria started back in 2007 out of a need of having a memory-efficient multi-dimensional spatial tree for function approximation, like this one. Contrary to traditional approaches for function approximation, like neural networks, spatial trees have much smaller computational complexity (logarithmic on average) for inference and allow computing partial and inverse functions out of the same set of parameters.</description></item><item><title>Hermes</title><link>https://memoria-framework.dev/docs/overview/hermes/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/hermes/</guid><description>In ancient Greek mythology Hermes is a messenger between gods and humans.
Basic information In the context of Memoria Framework, Hermes is a solution to the &amp;ldquo;last mile&amp;rdquo; data modelling problem. Containers can be used to model large amounts of highly structured data. Hermes is intended to represent relatively small amount of unstructured or semi-structured data and can be used together with containers. Notable feature of Hermes as a data format is that all objects and data types have canonical textual representation, so Hermes data can be consumed and produced by humans.</description></item><item><title>Containers</title><link>https://memoria-framework.dev/docs/overview/containers/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/containers/</guid><description>Basic Information Containers in Memoria are basic units of data modelling. Idiomatically, they are very much like STL containers except that, counterintuitively, container objects do not own their data, they use dedicated storage API for that. So data life-cycle is tied to the storage object, not the container object. In some cases (implementations) container objects may own their storage objects, but, typically, they don&amp;rsquo;t.
Note that there may be some terminological clash between Memoria containers discussed here and Hermes containers.</description></item><item><title>Storage Engines</title><link>https://memoria-framework.dev/docs/overview/storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/storage/</guid><description>Memoria has pluggable storage engines. Block storage API is isolated behind the IStore interface. Block life-cycle in the code is managed with RAII. As far as some block is used (directly or indirectly referenced) in the code, a storage engines knows about that and my, for example, keep it in a cache.
There are four &amp;lsquo;core&amp;rsquo; storage engines in Memoria, covering basic usage: in-memory, disk-based OLTP-optimized, analytics-optimized and &amp;lsquo;static immutable files&amp;rsquo;.</description></item><item><title>DSL &amp; VM</title><link>https://memoria-framework.dev/docs/overview/vm/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/vm/</guid><description>TBD</description></item><item><title>Runtime Environments</title><link>https://memoria-framework.dev/docs/overview/runtime/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/runtime/</guid><description>TBD</description></item><item><title>Memoria Build Tool</title><link>https://memoria-framework.dev/docs/overview/mbt/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/mbt/</guid><description>TBD</description></item><item><title>Qt Creator Instructions</title><link>https://memoria-framework.dev/docs/overview/qt_creator_instructions/</link><pubDate>Wed, 06 Jul 2022 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/qt_creator_instructions/</guid><description>Dependencies Memoria relies on third-party libraries that either may not be available on supported developenment platfroms or have outdated versions there. Vcpkg package manager is currently being used for dependency management. Memoria itself is avaialble via custom Vcpkg registry. Conan recipies and source packages for Linux distributions (via CPack) may be provided in the future.
See the Dockerfile on how to configure development environment on Ubuntu 22.04. Standard development environment will be the latest Ubuntu LTS.</description></item></channel></rss>