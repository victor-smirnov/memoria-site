<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Overview List on</title><link>https://memoria-framework.dev/docs/overview/</link><description>Recent content in Overview List on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:48:45 +0000</lastBuildDate><atom:link href="https://memoria-framework.dev/docs/overview/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Memoria</title><link>https://memoria-framework.dev/docs/overview/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/introduction/</guid><description>Data dominates. If you&amp;rsquo;ve chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.
&amp;ndash; Rob Pike in “Notes on Programming in C”, 1989.
Memoria is &amp;hellip;
a &amp;ldquo;full-stack&amp;rdquo; data-centric framework for latency-sensitive class of computations covering data- and knowledge bases, logical reasoners, constraint solving for both exact and approximate (including Any-Time) types of inference.</description></item><item><title>Philosophy</title><link>https://memoria-framework.dev/docs/overview/philosophy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/philosophy/</guid><description>TBC&amp;hellip;</description></item><item><title>Hermes</title><link>https://memoria-framework.dev/docs/overview/hermes/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/hermes/</guid><description>In ancient Greek mythology Hermes is a messenger between gods and humans.
Basic information In the context of Memoria Framework, Hermes is a solution to the &amp;ldquo;last mile&amp;rdquo; data modelling problem. Containers can be used to model large amounts of highly structured data. Hermes is intended to represent relatively small amount of unstructured or semi-structured data and can be used together with containers. Notable feature of Hermes as a data format is that all objects and data types have canonical textual representation, so Hermes data can be consumed and produced by humans.</description></item><item><title>HRPC: Hermes RPC Protocol</title><link>https://memoria-framework.dev/docs/overview/hrpc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/hrpc/</guid><description>Basic Information Hermes RPC (HRPC) is a design space of messaging protocols optimized for direct hardware implementation. HRPC is a pretty low-level protocol semantically adding just a little-bit over common networking models like UCP and TCP (point-to-point messaging, broadcasting streaming, etc).
Semantically, HRPC is very similar to gRPC and Cap&amp;rsquo;n-proto, so related skills and mental models, as well as programming patterns and paradigms are immediately applicable here. The purpose is also the same &amp;ndash; to simplify intreroperation between functional units in large systems.</description></item><item><title>Containers</title><link>https://memoria-framework.dev/docs/overview/containers/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/containers/</guid><description>Basic Information Containers in Memoria are basic units of data modelling. Idiomatically, they are very much like STL containers except that, counterintuitively, container objects do not own their data, they use dedicated storage API for that. So data life-cycle is tied to the storage object, not the container object. In some cases (implementations) container objects may own their storage objects, but, typically, they don&amp;rsquo;t.
Note that there may be some terminological clash between Memoria containers discussed here and Hermes containers.</description></item><item><title>Storage Engines</title><link>https://memoria-framework.dev/docs/overview/storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/storage/</guid><description>Memoria has pluggable storage engines. Block storage API is isolated behind the IStore interface. Block life-cycle in the code is managed with RAII. As far as some block is used (directly or indirectly referenced) in the code, a storage engines knows about that and my, for example, keep it in a cache.
There are four &amp;lsquo;core&amp;rsquo; storage engines in Memoria, covering basic usage: in-memory, disk-based OLTP-optimized, analytics-optimized and &amp;lsquo;static immutable files&amp;rsquo;.</description></item><item><title>Runtime Environments</title><link>https://memoria-framework.dev/docs/overview/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/runtime/</guid><description>Memoria tries to be a runtime-agnostic wherever it&amp;rsquo;s possible. There are two main dependencies: memory allocation and IO. Custom memory allocation is a rather easy thing. High-performance IO is much harder because we need facilities which are not properly supported by the programming language, operation system or both. Memoria relies on fibers for concurrency and they are expected to be supported for C++26 and is already available in various frameworks and libraries.</description></item><item><title>DSL Engine</title><link>https://memoria-framework.dev/docs/overview/vm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/vm/</guid><description>Introduction Historically, Memoria was meant to be a storage engine, leaving data processing aspects to applications. After trying Memoria in various projects involving C++ and Java it was clear that it&amp;rsquo;s not a good idea. To be used at its full potential, Memoria requires its own runtime environment. Bridging different runtimes like C++ with fibers and JVM is a close to impossible task, if efficiency is a goal. After experiments with PrestoDB on top of Memoria and development of String Data Notation format, recently superseded by Hermes, it became clear that Memoria needs its own integrated query execution engine.</description></item><item><title>Memoria Acceleration Architecture (MAA)</title><link>https://memoria-framework.dev/docs/overview/accel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/accel/</guid><description>Basic Information Processing can be compute-intensive, IO-intensive or combined/hybrid. Processing is compute intensive if each element of data is processed many times. Examples: sorting and matrix multiplication. Otherwise it&amp;rsquo;s IO-intensive. Example: hashtable with random access. Hybrid processing may contain both compute-intensive and IO-intensive stages, but they will be clearly separable. Like, in evaluating SQL query, JOIN is IO-intensive and SORT is compute-intensive. Physically, the more processing is compute-intensive, the less it&amp;rsquo;s IO-intensive.</description></item><item><title>Memoria Build Tool</title><link>https://memoria-framework.dev/docs/overview/mbt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/mbt/</guid><description>Memoria Build Tool (MBT) is a helper program with the scope of Memoria project (and out of it, if it&amp;rsquo;s fount to be helpful). It basically reads C++ sources (via Clang libs) and can:
Generate boilerplate code like bindings, Invoke compiler to do type inference, &amp;hellip; MBT is integrated with CMake and has a special mode to produce a list of artifacts that will be included into the project&amp;rsquo;s build process.</description></item></channel></rss>