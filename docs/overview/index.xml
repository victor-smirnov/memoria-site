<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Overview List on</title><link>https://memoria-framework.dev/docs/overview/</link><description>Recent content in Overview List on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:48:45 +0000</lastBuildDate><atom:link href="https://memoria-framework.dev/docs/overview/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction to Memoria</title><link>https://memoria-framework.dev/docs/overview/introduction/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/introduction/</guid><description>Data dominates. If you&amp;rsquo;ve chosen the right data structures and organized things well, the algorithms will almost always be self-evident. Data structures, not algorithms, are central to programming.
&amp;ndash; Rob Pike in “Notes on Programming in C”, 1989.
How it started&amp;hellip; Memoria started back in 2007 out of a need of having a memory-efficient multi-dimensional spatial tree for function approximation, like this one. Contrary to traditional approaches for function approximation, like neural networks, spatial trees have much smaller computational complexity (logarithmic on average) for inference and allow computing partial and inverse functions out of the same set of parameters.</description></item><item><title>Hermes</title><link>https://memoria-framework.dev/docs/overview/hermes/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/hermes/</guid><description>In ancient Greek mythology Hermes is a messenger between gods and humans.
Basic information In the context of Memoria Framework, Hermes is a solution to the &amp;ldquo;last mile&amp;rdquo; data modelling problem. Containers can be used to model large amounts of highly structured data. Hermes is intended to represent relatively small amount of unstructured or semi-structured data and can be used together with containers. Notable feature of Hermes as a data format is that all objects and data types have canonical textual representation, so Hermes data can be consumed and produced by humans.</description></item><item><title>Containers</title><link>https://memoria-framework.dev/docs/overview/containers/</link><pubDate>Tue, 06 Oct 2020 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/containers/</guid><description>Basic Information Containers in Memoria are basic units of data modelling. Idiomatically, they are very much like STL containers except that, counterintuitively, container objects do not own their data, they use dedicated storage API for that. So data life-cycle is tied to the storage object, not the container object. In some cases (implementations) container objects may own their storage objects, but, typically, they don&amp;rsquo;t.
Note that there may be some terminological clash between Memoria containers discussed here and Hermes containers.</description></item><item><title>Storage Engines</title><link>https://memoria-framework.dev/docs/overview/storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/storage/</guid><description>Memoria has pluggable storage engines. Block storage API is isolated behind the IStore interface. Block life-cycle in the code is managed with RAII. As far as some block is used (directly or indirectly referenced) in the code, a storage engines knows about that and my, for example, keep it in a cache.
There are four &amp;lsquo;core&amp;rsquo; storage engines in Memoria, covering basic usage: in-memory, disk-based OLTP-optimized, analytics-optimized and &amp;lsquo;static immutable files&amp;rsquo;.</description></item><item><title>Runtime Environments</title><link>https://memoria-framework.dev/docs/overview/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/runtime/</guid><description>Memoria tries to be a runtime-agnostic wherever it&amp;rsquo;s possible. There are two main dependencies: memory allocation and IO. Custom memory allocation is a rather easy thing. High-performance IO is much harder because we need facilities which are not properly supported by the programming language, operation system or both. Memoria relies on fibers for concurrency and they are expected to be supported for C++26 and is already available in various frameworks and libraries.</description></item><item><title>DSL Engine</title><link>https://memoria-framework.dev/docs/overview/vm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/vm/</guid><description>Introduction Historically, Memoria was meant to be a storage engine, leaving data processing aspects to applications. After trying Memoria in various projects involving C++ and Java it was clear that it&amp;rsquo;s not a good idea. To be used at its full potential, Memoria requires its own runtime environment. Bridging different runtimes like C++ with fibers and JVM is a close to impossible task, if efficiency is a goal. After experiments with PrestoDB on top of Memoria and development of String Data Notation format, recently superseded by Hermes, it became clear that Memoria needs its own integrated query execution engine.</description></item><item><title>Memoria Build Tool</title><link>https://memoria-framework.dev/docs/overview/mbt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/mbt/</guid><description>Memoria Build Tool (MBT) is a helper program with the scope of Memoria project (and out of it, if it&amp;rsquo;s fount to be helpful). It basically reads C++ sources (via Clang libs) and can:
Generate boilerplate code like bindings, Invoke compiler to do type inference, &amp;hellip; MBT is integrated with CMake and has a special mode to produce a list of artifacts that will be included into the project&amp;rsquo;s build process.</description></item><item><title>Qt Creator Instructions</title><link>https://memoria-framework.dev/docs/overview/qt_creator_instructions/</link><pubDate>Wed, 06 Jul 2022 08:48:57 +0000</pubDate><guid>https://memoria-framework.dev/docs/overview/qt_creator_instructions/</guid><description>Dependencies Memoria relies on third-party libraries that either may not be available on supported developenment platfroms or have outdated versions there. Vcpkg package manager is currently being used for dependency management. Memoria itself is avaialble via custom Vcpkg registry. Conan recipies and source packages for Linux distributions (via CPack) may be provided in the future.
See the Dockerfile on how to configure development environment on Ubuntu 22.04. Standard development environment will be the latest Ubuntu LTS.</description></item></channel></rss>