<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://memoria-framework.dev/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://memoria-framework.dev/main.4aee7b9c653a9441aeccbab4bf9a20bb4827ed71a21077328be36d74cbe63081492792ee312478e64d73f5e762a2ad3c04431ecfa8d16da63373639763e86b0c.css integrity="sha512-Su57nGU6lEGuzLq0v5ogu0gn7XGiEHcyi+NtdMvmMIFJJ5LuMSR45k1z9edioq08BEMez6jRbaYzc2OXY+hrDA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Containers - Memoria</title><meta name=description content><link rel=canonical href=https://memoria-framework.dev/docs/overview/containers/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Containers"><meta property="og:description" content="Basic Information Containers in Memoria are basic units of data modelling. Idiomatically, they are very much like STL containers except that, counterintuitively, container objects do not own their data, they use dedicated storage API for that. So data life-cycle is tied to the storage object, not the container object. In some cases (implementations) container objects may own their storage objects, but, typically, they don&rsquo;t.
Note that there may be some terminological clash between Memoria containers discussed here and Hermes containers."><meta property="og:url" content="https://memoria-framework.dev/docs/overview/containers/"><meta property="og:site_name" content="Memoria"><meta property="article:published_time" content="2020-10-06T08:48:57+00:00"><meta property="article:modified_time" content="2020-10-06T08:48:57+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="Containers"><meta name=twitter:description content><meta name=twitter:card content="summary"><meta name=twitter:image:alt content="Containers"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://memoria-framework.dev/#/schema/person/1","name":"Memoria","url":"https://memoria-framework.dev/","sameAs":[],"image":{"@type":"ImageObject","@id":"https://memoria-framework.dev/#/schema/image/1","url":"https://memoria-framework.dev/\u003cnil\u003e","width":null,"height":null,"caption":"Memoria"}},{"@type":"WebSite","@id":"https://memoria-framework.dev/#/schema/website/1","url":"https://memoria-framework.dev/","name":"Memoria","description":"","publisher":{"@id":"https://memoria-framework.dev/#/schema/person/1"}},{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/overview/containers/","url":"https://memoria-framework.dev/docs/overview/containers/","name":"Containers","description":"","isPartOf":{"@id":"https://memoria-framework.dev/#/schema/website/1"},"about":{"@id":"https://memoria-framework.dev/#/schema/person/1"},"datePublished":"2020-10-06T08:48:57CET","dateModified":"2020-10-06T08:48:57CET","breadcrumb":{"@id":"https://memoria-framework.dev/docs/overview/containers/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://memoria-framework.dev/docs/overview/containers/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://memoria-framework.dev/docs/overview/containers/"]}]},{"@type":"BreadcrumbList","@id":"https://memoria-framework.dev/docs/overview/containers/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/","url":"https://memoria-framework.dev/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/","url":"https://memoria-framework.dev/docs/","name":"Docs"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/overview/","url":"https://memoria-framework.dev/docs/overview/","name":"Overview"}},{"@type":"ListItem","position":4,"item":{"@id":"https://memoria-framework.dev/docs/overview/containers/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://memoria-framework.dev/#/schema/article/1","headline":"Containers","description":"","isPartOf":{"@id":"https://memoria-framework.dev/docs/overview/containers/"},"mainEntityOfPage":{"@id":"https://memoria-framework.dev/docs/overview/containers/"},"datePublished":"2020-10-06T08:48:57CET","dateModified":"2020-10-06T08:48:57CET","author":{"@id":"https://memoria-framework.dev/#/schema/person/2"},"publisher":{"@id":"https://memoria-framework.dev/#/schema/person/1"},"image":{"@id":"https://memoria-framework.dev/docs/overview/containers/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://memoria-framework.dev/#/schema/person/2","name":"Victor Smirnov","sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://memoria-framework.dev/docs/overview/containers/#/schema/image/2","url":null,"contentUrl":null,"caption":"Containers"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://memoria-framework.dev/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://memoria-framework.dev/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://memoria-framework.dev/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://memoria-framework.dev/site.webmanifest></head><body class="docs single"><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=Memoria>Memoria</a>
<button class="btn btn-menu d-block d-md-none order-5" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-start border-0 py-md-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-md-none"></div><div class="offcanvas-header d-md-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>Memoria</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body px-4"><h3 class="h6 text-uppercase mb-3 d-md-none">Main</h3><ul class="nav flex-column flex-md-row ms-md-n3"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/docs/overview/introduction/>Docs</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/subprojects/overview/>Subprojects</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/issues>Issues</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/discussions>Discussions</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/wiki>Releases</a></li></ul><hr class="text-black-50 my-4 d-md-none"><h3 class="h6 text-uppercase mb-3 d-md-none">Socials</h3><ul class="nav flex-column flex-md-row ms-md-auto me-md-n5 pe-md-2"><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-md-none">GitHub</small></a></li></ul></div></div></nav></header><nav class="doks-subnavbar py-2 sticky-lg-top" aria-label="Secondary navigation"><div class="container-xxl d-flex align-items-md-center"><form class="doks-search position-relative flex-grow-1 me-auto"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><button class="btn doks-sidebar-toggle d-lg-none ms-3 order-3 collapsed" type=button data-bs-toggle=collapse data-bs-target=#doks-docs-nav aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle documentation navigation"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></button></div></nav><div class=container-xxl><aside class=doks-sidebar><nav id=doks-docs-nav class="collapse d-lg-none" aria-label="Tertiary navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-overview aria-expanded=true>
Overview</button><div class="collapse show" id=section-overview><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/overview/introduction/>Introduction to Memoria Framework</a></li><li><a class="docs-link rounded" href=/docs/overview/philosophy/>Philosophy</a></li><li><a class="docs-link rounded" href=/docs/overview/hermes/>Hermes</a></li><li><a class="docs-link rounded" href=/docs/overview/hrpc/>HRPC: Hermes RPC Protocol</a></li><li><a class="docs-link rounded active" href=/docs/overview/containers/>Containers</a></li><li><a class="docs-link rounded" href=/docs/overview/storage/>Storage Engines</a></li><li><a class="docs-link rounded" href=/docs/overview/runtime/>Runtime Environments</a></li><li><a class="docs-link rounded" href=/docs/overview/vm/>DSL Engine</a></li><li><a class="docs-link rounded" href=/docs/overview/accel/>Memoria Acceleration Architecture (MAA)</a></li><li><a class="docs-link rounded" href=/docs/overview/mbt/>Memoria Build Tool</a></li><li><a class="docs-link rounded" href=/docs/overview/qt_creator_instructions/>Qt Creator Instructions</a></li><li><a class="docs-link rounded" href=/docs/overview/roadmap/>Project Roadmap</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-datazoo aria-expanded=false>
Data Zoo</button><div class=collapse id=section-datazoo><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/data-zoo/overview/>Core Data Structures -- Overview</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/partial-sum-tree/>Partial Sums Tree</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/searchable-seq/>Searchable Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/compressed-symbol-seq/>Compressed Symbol Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/hierarchical-containers/>Hierarchical Containers</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/louds-tree/>Level Order Unary Degree Sequence (LOUDS)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/wavelet-tree/>Multiary Wavelet Trees</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/packed-allocator/>Packed Allocator</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-1/>Associative Memory (Part 1)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-2/>Associative Memory (Part 2)</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-apps aria-expanded=false>
Applications</button><div class=collapse id=section-apps><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/applications/aiml/>Hybrid AI</a></li><li><a class="docs-link rounded" href=/docs/applications/storage/>Computational Storage</a></li><li><a class="docs-link rounded" href=/docs/applications/db/>Converged Databases</a></li><li><a class="docs-link rounded" href=/docs/applications/co-design/>HW/SW Co-design</a></li><li><a class="docs-link rounded" href=/docs/applications/eiot/>Embedded and IoT Applications</a></li></ul></div></li></ul></nav></aside></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar d-none d-lg-block"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-overview aria-expanded=true>
Overview</button><div class="collapse show" id=section-overview><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/overview/introduction/>Introduction to Memoria Framework</a></li><li><a class="docs-link rounded" href=/docs/overview/philosophy/>Philosophy</a></li><li><a class="docs-link rounded" href=/docs/overview/hermes/>Hermes</a></li><li><a class="docs-link rounded" href=/docs/overview/hrpc/>HRPC: Hermes RPC Protocol</a></li><li><a class="docs-link rounded active" href=/docs/overview/containers/>Containers</a></li><li><a class="docs-link rounded" href=/docs/overview/storage/>Storage Engines</a></li><li><a class="docs-link rounded" href=/docs/overview/runtime/>Runtime Environments</a></li><li><a class="docs-link rounded" href=/docs/overview/vm/>DSL Engine</a></li><li><a class="docs-link rounded" href=/docs/overview/accel/>Memoria Acceleration Architecture (MAA)</a></li><li><a class="docs-link rounded" href=/docs/overview/mbt/>Memoria Build Tool</a></li><li><a class="docs-link rounded" href=/docs/overview/qt_creator_instructions/>Qt Creator Instructions</a></li><li><a class="docs-link rounded" href=/docs/overview/roadmap/>Project Roadmap</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-datazoo aria-expanded=false>
Data Zoo</button><div class=collapse id=section-datazoo><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/data-zoo/overview/>Core Data Structures -- Overview</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/partial-sum-tree/>Partial Sums Tree</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/searchable-seq/>Searchable Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/compressed-symbol-seq/>Compressed Symbol Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/hierarchical-containers/>Hierarchical Containers</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/louds-tree/>Level Order Unary Degree Sequence (LOUDS)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/wavelet-tree/>Multiary Wavelet Trees</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/packed-allocator/>Packed Allocator</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-1/>Associative Memory (Part 1)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-2/>Associative Memory (Part 2)</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-apps aria-expanded=false>
Applications</button><div class=collapse id=section-apps><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/applications/aiml/>Hybrid AI</a></li><li><a class="docs-link rounded" href=/docs/applications/storage/>Computational Storage</a></li><li><a class="docs-link rounded" href=/docs/applications/db/>Converged Databases</a></li><li><a class="docs-link rounded" href=/docs/applications/co-design/>HW/SW Co-design</a></li><li><a class="docs-link rounded" href=/docs/applications/eiot/>Embedded and IoT Applications</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#basic-information>Basic Information</a></li><li><a href=#concurrency-and-parallelism>Concurrency and Parallelism</a></li><li><a href=#storage-agnostic>Storage-agnostic</a></li><li><a href=#definitive-example>Definitive Example</a></li><li><a href=#compositionality-and-instantiation-of-containers>Compositionality and Instantiation of Containers</a></li><li><a href=#metaprogramming-framework>Metaprogramming Framework</a></li><li><a href=#source-code-entry-points>Source code entry points</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>Containers</h1><p class=lead></p><nav class=d-xl-none aria-label="Quaternary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#basic-information>Basic Information</a></li><li><a href=#concurrency-and-parallelism>Concurrency and Parallelism</a></li><li><a href=#storage-agnostic>Storage-agnostic</a></li><li><a href=#definitive-example>Definitive Example</a></li><li><a href=#compositionality-and-instantiation-of-containers>Compositionality and Instantiation of Containers</a></li><li><a href=#metaprogramming-framework>Metaprogramming Framework</a></li><li><a href=#source-code-entry-points>Source code entry points</a></li></ul></nav></div></nav><h2 id=basic-information>Basic Information<a href=#basic-information class=anchor aria-hidden=true>#</a></h2><p>Containers in Memoria are basic units of data modelling. Idiomatically, they are very much like STL containers except that, counterintuitively, container objects do not <em>own</em> their data, they use dedicated storage API for that. So data life-cycle is tied to the <em>storage</em> object, not the <em>container</em> object. In some cases (implementations) container objects may own their storage objects, but, typically, they don&rsquo;t.</p><p>Note that there may be some terminological clash between Memoria containers discussed here and <a href=/docs/overview/hermes>Hermes</a> containers. The latter are classical STL-like containers owning their data.</p><p>Memoria containers are block-organized. Blocks may be of arbitrary size, up to 2GB, there are no inherent limitations, but their size is typically multiple of the storage/memory block size. Like, 4K, 8K, &mldr; The upper limit is storage-dependent. Disk-based storage engines do not allow blocks over 1MB in size for practical reasons.</p><p><a href=/docs/data-zoo/packed-allocator/>Packed Allocator</a> is a mechanism that is used in Memoria to place data (allocate objects) in memory blocks.</p><p>Blocks are organized into linked data structures using <em>block identifiers</em>. Conceptually, an identifier may be of arbitrary <em>fixed size</em> type (integer, UUID, &mldr;), but Memoria provides dedicated type set for that.</p><p>The most common linked data structure used for containers is a <em>variant</em> of B+Tree. This variant is mainly different from a <a href=https://en.wikipedia.org/wiki/B%2B_tree>standard one</a> is that there are no <em>sibling links</em>. There are also no <em>parent links</em> in the tree, this is necessary for <a href=https://en.wikipedia.org/wiki/Persistent_data_structure>persistence</a>. So, in some cases B+Trees in Memoria will be less efficient than standard ones.</p><p>Lack of <em>sibling links</em> is not a big issue, because tree-walking overhead for B+Trees with large (4K+) blocks is pretty moderate.</p><p>Lack of <em>parent links</em> is more impacting, because iterators now need to keep <em>full path</em> form root to the current node. Iterator is a stack-like data structure, not just a current block ID. A lot fo tree-updating code becomes much more complicated comparing to the variant with parent links, but this is the price we pay for having persistence, concurrency and parallelism.</p><h2 id=concurrency-and-parallelism>Concurrency and Parallelism<a href=#concurrency-and-parallelism class=anchor aria-hidden=true>#</a></h2><p>Containers in Memoria are <strong>not</strong> thread safe, and this is foundational design decision to make data structures simpler. All thread-safety, if any, are provided at the level of storage engines. And the main concurrency and parallelism mechanism Memoria relies on is <a href=https://en.wikipedia.org/wiki/Persistent_data_structure>persistent/functional</a> data structures. This feature also comes with its design costs, limitations and overheads. But it also gives Memoria all of its batteries and superpowers.</p><p>So, B+Tree-based containers in Memoria can be of two implementation types:</p><ol><li><strong>Copy-on-Write-based (CoW)</strong> containers. Persistence is supported at the level of containers. This is the fastest option but at the expense of more complicated container design. All container types need to align with CoW semantics, that is well-encapsulated by the Framework.</li><li><strong>Epithemeral (non-CoW)</strong> containers. This type of containers do not explicitly support CoW semantics themselves, so the <em>may</em> have parent and sibling links if necessary. But for the sake of code unification and reuse, they <em>don&rsquo;t</em>. CoW semantics may still be supported at the level of <em>storage engines</em>. For example, there is a variant of storage engine on top of the <a href=http://www.lmdb.tech/doc/>LMDB</a> database that has strongly serialized CoW-based transactions. When working on top of such storage engines, containers do not need to provide their own CoW semantics.</li></ol><h2 id=storage-agnostic>Storage-agnostic<a href=#storage-agnostic class=anchor aria-hidden=true>#</a></h2><p>From a container&rsquo;s perspective, block storage is completely decoupled and can be fully software-defined.</p><figure><img src=io.svg></figure><p>For more details on that see the <a href=/docs/overview/storage/>Storage engines</a> section.</p><h2 id=definitive-example>Definitive Example<a href=#definitive-example class=anchor aria-hidden=true>#</a></h2><pre><code class=language-c++>// We will be using in-memory store
#include &lt;memoria/api/store/memory_store_api.hpp&gt;
// And a simple Set&lt;&gt; container
#include &lt;memoria/api/set/set_api.hpp&gt;
// Static initialization stuff
#include &lt;memoria/memoria.hpp&gt;

using namespace memoria;

int main(void) {
    // Create a store first. All data is in a store object.
    // We will be using an in-memory store
    auto store = create_memory_store();

    // In-memory store is a confluently-persistent CoW-enabled store,
    // so it suppoerts Git-like branching for containers.
    // We are opening new snapshot from the master branch.
    auto snapshot = store-&gt;master()-&gt;branch();

    // Now let's create a container, it will be a set of short strings.
    // First, we need to define a datatype for container:
    using DataType = Set&lt;Varchar&gt;;
    // See Hermes docs for more information about datatypes.

    // Now lets create a new set container in our snapshot
    auto set_ctr = create&lt;DataType&gt;(snapshot, DataType{});

    // .. and insert a few strings into it
    for (size_t c = 0; c &lt; 10; c++) {
        set_ctr-&gt;upsert(std::string(&quot;Entry for &quot;) + std::to_string(c));
    }

    // Now we are ready to iterate over inserted entries.
    set_ctr-&gt;for_each([](auto entry){
        println(&quot;{}&quot;, entry);
    });

    // After we are done with inserting data, we can commit the snapshot
    // so it will be avaliable for other threads to branch from.
    snapshot-&gt;commit();

    // And we can store the data into a file
    store-&gt;store(&quot;set-data.mma&quot;);

    // Here all the data will be destroyed in memory,
    // but will remain in the file
}

</code></pre><p>This example mentions using <a href=/docs/overview/hermes/#datatypes>Hermes datatypes</a>. Container type is defined by its <em>Datatype</em>, that is, basically a combination of C++ class and some <em>state</em>, that will be shared between all objects of this datatype. Note that all datatypes in Memoria are currently stateless, so they look exactly like C++ classes.</p><p>Working code this this example can be found <a href=https://github.com/victor-smirnov/memoria/blob/master/examples/simple_set.cpp>here</a>.</p><h2 id=compositionality-and-instantiation-of-containers>Compositionality and Instantiation of Containers<a href=#compositionality-and-instantiation-of-containers class=anchor aria-hidden=true>#</a></h2><p>STL containers are pretty lightweight and are instantiated at the site of usage. They support composition, so we can easily define composite multimap container like <code>std::map&lt;int64_t, std::vector&lt;std::string>></code>. Memoria containers use b+trees aiming to support external memory and have no such luxury of composition. Moreover, arbitrary C++ objects like <code>std::string</code> <em>can&rsquo;t be</em> used as datatypes, because their memory management is incompatible with internal b+tree machinery. So, instead of STL&rsquo;s compositionality, Memoria provides complex, datatype-optimized containers. Like, STL implementation of multimap becomes <code>Multimap&lt;Int64, Varchar></code>. Framework provides complex containers for many practical use cases.</p><p>Memoria containers are instantiated in a library and usually comes in a pre-compiled form. The problem is that pre-instantiation of container for all combinations of datatypes is infeasible. Memoria libraries provide the most idiomatic and commonly used ones, and applications are free to instantiate their own variants, it&rsquo;s fully supported.</p><p>The following line may look like an instantiation of a template at the call site:</p><pre><code class=language-c++>auto set_ctr = create&lt;DataType&gt;(snapshot, DataType{});
</code></pre><p>But there is no actual instantiation here. Instead, datatype&rsquo;s metrics (typehash code) is used to find actual instantiation in the instantiations registry.</p><p>In other for this mechanism to be really lightweight at the call-cite and work properly, containers need to have abstract <em>public</em> virtual interfaces and <em>private</em> implementations that are hidden from the application code.</p><p>Containers have pretty complex lifecicle and metadata systems, as well as integration with Hermes and datatypes, so developing a new container may be a challenge. Memoria uses in-house <a href=/docs/overview/mbt/>Build Tool</a> to automate these processes.</p><h2 id=metaprogramming-framework>Metaprogramming Framework<a href=#metaprogramming-framework class=anchor aria-hidden=true>#</a></h2><p>This is one of the most complex part of the Framework, especially because C++ isn&rsquo;t that good with <em>metaprogramming in large</em>. There were no much better alternatives back in the days when Memoria started, there are not that many of them now. This issue is going to be addressed low-level languages that support homoiconic compile-time metaprogramming, like Zig and (as it&rsquo;s being promised) Mojo. Memoria&rsquo;s <a href=/docs/overview/vm>DSL subsystem</a> is also addressing this issue too. Nevertheless, for container-level metaprogramming we currently only have what <em>latest</em> C++ standard is offering.</p><p>Memoria Containers are build using Partial Class programming pattern. Partial Class definition may be split between many files. Containers classes are built from <a href=https://github.com/victor-smirnov/memoria/tree/master/containers/include/memoria/containers/set/container>parts</a> using the information provided from three places:</p><ol><li>Container <a href=https://github.com/victor-smirnov/memoria/tree/master/containers/include/memoria/prototypes>prototype</a>. Prototype is a complex, Memoria-specific, form of a <em>base class</em>.</li><li>Container Datatype, like <code>Set&lt;Varchar></code>.</li><li><a href=https://github.com/victor-smirnov/memoria/tree/master/containers-api/include/memoria/profiles>Profile</a>. Profiles are an elaborate system of type traits (configurations) that define various <em>common</em> parameters, like CoW/non-Cow, type of block identifier, type of snapshot identifier and so on. Dozens of them.</li><li><a href=https://github.com/victor-smirnov/memoria/blob/master/containers/include/memoria/prototypes/bt/bt_factory.hpp>Type Factory</a> is a metaprogramming engine building container classes out of all this stuff above.</li></ol><h2 id=source-code-entry-points>Source code entry points<a href=#source-code-entry-points class=anchor aria-hidden=true>#</a></h2><ol><li><a href=https://github.com/victor-smirnov/memoria/tree/master/containers-api/include/memoria/api>Public Containers API</a>.</li><li><a href=https://github.com/victor-smirnov/memoria/tree/master/containers/include/memoria/containers>Private Containers Implementations</a></li><li><a href=https://github.com/victor-smirnov/memoria/blob/master/codegen/include/codegen_memoria.hpp>Default Container Instantiations</a> (Build Tool metadata)</li></ol><div class="docs-navigation d-flex justify-content-between"><a href=/docs/overview/hrpc/><div class="card my-1"><div class="card-body py-2">&larr; HRPC: Hermes RPC Protocol</div></div></a><a class=ms-auto href=/docs/overview/storage/><div class="card my-1"><div class="card-body py-2">Storage Engines &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://www.github.com/>Github</a>, <a href=https://gohugo.io/>Hugo</a>, and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/privacy-policy/>Privacy</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.73ca27033146a505b6a0f66b79d99f613a18e778bc9606fd223476d0ebf0fc10508b0d4f5c448b0a946fa1d71fbeffaae9732adc0c2890e61c449217fd6ee1c0.js integrity="sha512-c8onAzFGpQW2oPZredmfYToY53i8lgb9IjR20Ovw/BBQiw1PXESLCpRvodcfvv+q6XMq3AwokOYcRJIX/W7hwA==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.c5b6bb65307e087bfc3dd5a73cf000f3dc6a8b665db8c3fcbd62a3368e2f82ee494fd1ff5f025a09216cf6390bac7565c5469c6958caac1b9d09c85ba0adfefc.js integrity="sha512-xba7ZTB+CHv8PdWnPPAA89xqi2ZduMP8vWKjNo4vgu5JT9H/XwJaCSFs9jkLrHVlxUacaVjKrBudCchboK3+/A==" crossorigin=anonymous defer></script>
<script src=/js/vendor/katex/dist/katex.min.07c5862e6eea64c90e601fcaacaa0dbdb03f60dbbac68a5a5830130a00332df28001a5fa2375b739426606b441725db1af012c7e4b04b8fb222025cc0d2ac073.js integrity="sha512-B8WGLm7qZMkOYB/KrKoNvbA/YNu6xopaWDATCgAzLfKAAaX6I3W3OUJmBrRBcl2xrwEsfksEuPsiICXMDSrAcw==" crossorigin=anonymous defer></script>
<script src=/js/vendor/katex/dist/contrib/auto-render.min.bc779bab10cdc862f139e7cd6255a8f021bc483db2b7bc6d553238fb220e937dbe5cd511100d2ab764ee5d9f9092a2cdcc4e6ae109966efc18338f0b275d927d.js integrity="sha512-vHebqxDNyGLxOefNYlWo8CG8SD2yt7xtVTI4+yIOk32+XNUREA0qt2TuXZ+QkqLNzE5q4QmWbvwYM48LJ12SfQ==" crossorigin=anonymous defer></script>
<script src=/main.min.56cf146845ee56429c57a9bb74bee52540a1aa942a32506ad0d185db760f2f7a5d76f39cde824735c8b7e89f2e4453cc4da383eaa2c2a7d6a2c9dafd7061e74d.js integrity="sha512-Vs8UaEXuVkKcV6m7dL7lJUChqpQqMlBq0NGF23YPL3pddvOc3oJHNci36J8uRFPMTaOD6qLCp9aiydr9cGHnTQ==" crossorigin=anonymous defer></script>
<script src=https://memoria-framework.dev/index.min.3032b0a7db9a03a349f129e269d3832fd9e9c0fa6884a03459e7218390803928785fc95640c14ad407893c91f3bd6febd3521fd65b791e785dd0a25ae83a6438.js integrity="sha512-MDKwp9uaA6NJ8SniadODL9npwPpohKA0Wechg5CAOSh4X8lWQMFK1AeJPJHzvW/r01If1lt5Hnhd0KJa6DpkOA==" crossorigin=anonymous defer></script></body></html>