<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=https://memoria-framework.dev/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/KaTeX_Main-Regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=https://memoria-framework.dev/fonts/KaTeX_Math-Italic.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=https://memoria-framework.dev/main.4aee7b9c653a9441aeccbab4bf9a20bb4827ed71a21077328be36d74cbe63081492792ee312478e64d73f5e762a2ad3c04431ecfa8d16da63373639763e86b0c.css integrity="sha512-Su57nGU6lEGuzLq0v5ogu0gn7XGiEHcyi+NtdMvmMIFJJ5LuMSR45k1z9edioq08BEMez6jRbaYzc2OXY+hrDA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Hierarchical Containers - Memoria</title><meta name=description content><link rel=canonical href=https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="Hierarchical Containers"><meta property="og:description" content="In this page it&rsquo;s explained how various hierarchical containers (vectors with large values, multimaps, tables, wide tables, etc) are organized inside and how searchable sequences make it possible.
Multimap Let, for simplicity, we have a multimap std::map<int64_t, std::vector<uint8_t>> (we call it a Multimap here) that is internally a binary search tree (RB-/AVL-tree etc) with vectors as values. Vector is internally a contiguous data structure but the search tree is basically a tree-shaped linked list or pointer chasing data structure."><meta property="og:url" content="https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/"><meta property="og:site_name" content="Memoria"><meta property="article:published_time" content="2021-10-28T02:07:01-04:00"><meta property="article:modified_time" content="2021-10-28T02:07:01-04:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content><meta name=twitter:creator content><meta name=twitter:title content="Hierarchical Containers"><meta name=twitter:description content><meta name=twitter:card content="summary"><meta name=twitter:image:alt content="Hierarchical Containers"><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://memoria-framework.dev/#/schema/person/1","name":"Memoria","url":"https://memoria-framework.dev/","sameAs":[],"image":{"@type":"ImageObject","@id":"https://memoria-framework.dev/#/schema/image/1","url":"https://memoria-framework.dev/\u003cnil\u003e","width":null,"height":null,"caption":"Memoria"}},{"@type":"WebSite","@id":"https://memoria-framework.dev/#/schema/website/1","url":"https://memoria-framework.dev/","name":"Memoria","description":"","publisher":{"@id":"https://memoria-framework.dev/#/schema/person/1"}},{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/","url":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/","name":"Hierarchical Containers","description":"","isPartOf":{"@id":"https://memoria-framework.dev/#/schema/website/1"},"about":{"@id":"https://memoria-framework.dev/#/schema/person/1"},"datePublished":"2021-10-28T02:07:01CET","dateModified":"2021-10-28T02:07:01CET","breadcrumb":{"@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/#/schema/image/2"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/"]}]},{"@type":"BreadcrumbList","@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/","url":"https://memoria-framework.dev/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/","url":"https://memoria-framework.dev/docs/","name":"Docs"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://memoria-framework.dev/docs/data-zoo/","url":"https://memoria-framework.dev/docs/data-zoo/","name":"Data Zoo"}},{"@type":"ListItem","position":4,"item":{"@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://memoria-framework.dev/#/schema/article/1","headline":"Hierarchical Containers","description":"","isPartOf":{"@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/"},"mainEntityOfPage":{"@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/"},"datePublished":"2021-10-28T02:07:01CET","dateModified":"2021-10-28T02:07:01CET","author":{"@id":"https://memoria-framework.dev/#/schema/person/2"},"publisher":{"@id":"https://memoria-framework.dev/#/schema/person/1"},"image":{"@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://memoria-framework.dev/#/schema/person/2","name":"Victor Smirnov","sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/#/schema/image/2","url":null,"contentUrl":null,"caption":"Hierarchical Containers"}]}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=https://memoria-framework.dev/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://memoria-framework.dev/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://memoria-framework.dev/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://memoria-framework.dev/site.webmanifest></head><body class="docs single"><div class=header-bar></div><header class="navbar navbar-expand-md navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-auto" href=/ aria-label=Memoria>Memoria</a>
<button class="btn btn-menu d-block d-md-none order-5" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-start border-0 py-md-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-md-none"></div><div class="offcanvas-header d-md-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/>Memoria</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body px-4"><h3 class="h6 text-uppercase mb-3 d-md-none">Main</h3><ul class="nav flex-column flex-md-row ms-md-n3"><li class=nav-item><a class="nav-link ps-0 py-1 active" href=/docs/overview/introduction/>Docs</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/subprojects/overview/>Subprojects</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/issues>Issues</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/discussions>Discussions</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria/wiki>Releases</a></li></ul><hr class="text-black-50 my-4 d-md-none"><h3 class="h6 text-uppercase mb-3 d-md-none">Socials</h3><ul class="nav flex-column flex-md-row ms-md-auto me-md-n5 pe-md-2"><li class=nav-item><a class="nav-link ps-0 py-1" href=https://github.com/victor-smirnov/memoria><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-md-none">GitHub</small></a></li></ul></div></div></nav></header><nav class="doks-subnavbar py-2 sticky-lg-top" aria-label="Secondary navigation"><div class="container-xxl d-flex align-items-md-center"><form class="doks-search position-relative flex-grow-1 me-auto"><input id=search class="form-control is-search" type=search placeholder="Search docs..." aria-label="Search docs..." autocomplete=off><div id=suggestions class="shadow bg-white rounded d-none"></div></form><button class="btn doks-sidebar-toggle d-lg-none ms-3 order-3 collapsed" type=button data-bs-toggle=collapse data-bs-target=#doks-docs-nav aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle documentation navigation"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></button></div></nav><div class=container-xxl><aside class=doks-sidebar><nav id=doks-docs-nav class="collapse d-lg-none" aria-label="Tertiary navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-overview aria-expanded=false>
Overview</button><div class=collapse id=section-overview><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/overview/introduction/>Introduction to Memoria</a></li><li><a class="docs-link rounded" href=/docs/overview/philosophy/>Philosophy</a></li><li><a class="docs-link rounded" href=/docs/overview/hermes/>Hermes</a></li><li><a class="docs-link rounded" href=/docs/overview/hrpc/>HRPC: Hermes RPC Protocol</a></li><li><a class="docs-link rounded" href=/docs/overview/containers/>Containers</a></li><li><a class="docs-link rounded" href=/docs/overview/storage/>Storage Engines</a></li><li><a class="docs-link rounded" href=/docs/overview/runtime/>Runtime Environments</a></li><li><a class="docs-link rounded" href=/docs/overview/vm/>DSL Engine</a></li><li><a class="docs-link rounded" href=/docs/overview/accel/>Memoria Acceleration Architecture (MAA)</a></li><li><a class="docs-link rounded" href=/docs/overview/mbt/>Memoria Build Tool</a></li><li><a class="docs-link rounded" href=/docs/overview/qt_creator_instructions/>Qt Creator Instructions</a></li><li><a class="docs-link rounded" href=/docs/overview/roadmap/>Project Roadmap</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-datazoo aria-expanded=true>
Data Zoo</button><div class="collapse show" id=section-datazoo><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/data-zoo/overview/>Core Data Structures -- Overview</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/partial-sum-tree/>Partial Sums Tree</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/searchable-seq/>Searchable Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/compressed-symbol-seq/>Compressed Symbol Sequence</a></li><li><a class="docs-link rounded active" href=/docs/data-zoo/hierarchical-containers/>Hierarchical Containers</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/louds-tree/>Level Order Unary Degree Sequence (LOUDS)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/wavelet-tree/>Multiary Wavelet Trees</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/packed-allocator/>Packed Allocator</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-1/>Associative Memory (Part 1)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-2/>Associative Memory (Part 2)</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-apps aria-expanded=false>
Applications</button><div class=collapse id=section-apps><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/applications/aiml/>Hybrid AI</a></li><li><a class="docs-link rounded" href=/docs/applications/storage/>Computational Storage</a></li><li><a class="docs-link rounded" href=/docs/applications/db/>Converged Databases</a></li><li><a class="docs-link rounded" href=/docs/applications/co-design/>HW/SW Co-design</a></li><li><a class="docs-link rounded" href=/docs/applications/eiot/>Embedded and IoT Applications</a></li></ul></div></li></ul></nav></aside></div><div class="wrap container-xxl" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar d-none d-lg-block"><nav class=docs-links aria-label="Main navigation"><ul class="list-unstyled collapsible-sidebar"><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-overview aria-expanded=false>
Overview</button><div class=collapse id=section-overview><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/overview/introduction/>Introduction to Memoria</a></li><li><a class="docs-link rounded" href=/docs/overview/philosophy/>Philosophy</a></li><li><a class="docs-link rounded" href=/docs/overview/hermes/>Hermes</a></li><li><a class="docs-link rounded" href=/docs/overview/hrpc/>HRPC: Hermes RPC Protocol</a></li><li><a class="docs-link rounded" href=/docs/overview/containers/>Containers</a></li><li><a class="docs-link rounded" href=/docs/overview/storage/>Storage Engines</a></li><li><a class="docs-link rounded" href=/docs/overview/runtime/>Runtime Environments</a></li><li><a class="docs-link rounded" href=/docs/overview/vm/>DSL Engine</a></li><li><a class="docs-link rounded" href=/docs/overview/accel/>Memoria Acceleration Architecture (MAA)</a></li><li><a class="docs-link rounded" href=/docs/overview/mbt/>Memoria Build Tool</a></li><li><a class="docs-link rounded" href=/docs/overview/qt_creator_instructions/>Qt Creator Instructions</a></li><li><a class="docs-link rounded" href=/docs/overview/roadmap/>Project Roadmap</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-datazoo aria-expanded=true>
Data Zoo</button><div class="collapse show" id=section-datazoo><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/data-zoo/overview/>Core Data Structures -- Overview</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/partial-sum-tree/>Partial Sums Tree</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/searchable-seq/>Searchable Sequence</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/compressed-symbol-seq/>Compressed Symbol Sequence</a></li><li><a class="docs-link rounded active" href=/docs/data-zoo/hierarchical-containers/>Hierarchical Containers</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/louds-tree/>Level Order Unary Degree Sequence (LOUDS)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/wavelet-tree/>Multiary Wavelet Trees</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/packed-allocator/>Packed Allocator</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-1/>Associative Memory (Part 1)</a></li><li><a class="docs-link rounded" href=/docs/data-zoo/associative-memory-2/>Associative Memory (Part 2)</a></li></ul></div></li><li class=mb-1><button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle=collapse data-bs-target=#section-apps aria-expanded=false>
Applications</button><div class=collapse id=section-apps><ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small"><li><a class="docs-link rounded" href=/docs/applications/aiml/>Hybrid AI</a></li><li><a class="docs-link rounded" href=/docs/applications/storage/>Computational Storage</a></li><li><a class="docs-link rounded" href=/docs/applications/db/>Converged Databases</a></li><li><a class="docs-link rounded" href=/docs/applications/co-design/>HW/SW Co-design</a></li><li><a class="docs-link rounded" href=/docs/applications/eiot/>Embedded and IoT Applications</a></li></ul></div></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#multimap>Multimap</a><ul><li><a href=#data-structure>Data structure</a></li><li><a href=#representing-relational-tables>Representing relational tables</a></li></ul></li><li><a href=#multimap-with-searchable-values>Multimap with searchable values</a></li><li><a href=#wide-table>Wide Table</a></li><li><a href=#generalized-hierarchical-container>Generalized Hierarchical Container</a></li><li><a href=#multistream-btree>Multistream B+Tree.</a></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9"><h1>Hierarchical Containers</h1><p class=lead></p><nav class=d-xl-none aria-label="Quaternary navigation"><div class=page-links><h3>On this page</h3><nav id=TableOfContents><ul><li><a href=#multimap>Multimap</a><ul><li><a href=#data-structure>Data structure</a></li><li><a href=#representing-relational-tables>Representing relational tables</a></li></ul></li><li><a href=#multimap-with-searchable-values>Multimap with searchable values</a></li><li><a href=#wide-table>Wide Table</a></li><li><a href=#generalized-hierarchical-container>Generalized Hierarchical Container</a></li><li><a href=#multistream-btree>Multistream B+Tree.</a></li></ul></nav></div></nav><p>In this page it&rsquo;s explained how various hierarchical containers (vectors with large values, multimaps, tables, wide tables, etc) are organized inside and how <a href=/docs/data-zoo/searchable-seq/>searchable sequences</a> make it possible.</p><h2 id=multimap>Multimap<a href=#multimap class=anchor aria-hidden=true>#</a></h2><p>Let, for simplicity, we have a multimap <code>std::map&lt;int64_t, std::vector&lt;uint8_t>></code> (we call it a <em>Multimap</em> here) that is internally a binary search tree (RB-/AVL-tree etc) with vectors as values. Vector<t> is internally a contiguous data structure but the search tree is basically a tree-shaped linked list or <em>pointer chasing</em> data structure. This data layout works perfectly for the <em>word</em>-addressed main memory, but if we want to place out data structure into <em>block</em>-addressed external memory, the whole thing gets trickier, because the using of allocation now is pretty large comparing to RAM: 4KB and greater. In the external memory we can still combine Map (represented as B+Tree) with Dynamic Vector (represented as B+Tree) the same way how two those containers <code>std::map&lt;></code> and <code>std::vector&lt;></code> are combined with each other (via references) and get either a set of B+Trees or one &lsquo;hierarchical&rsquo; B+Tree, but the minimal size of value vector will be <em>one block</em> that is pretty large. Practical applications can optimize this specific case using various techniques like placing short vectors right inside the parent container&rsquo;s (Map in this case) leaf block, and only spilling a new B+Tree when there is no more room for that in the block. It works pretty well in practice, but we can do much better. Below it&rsquo;s explained how we can use searchable sequences for fitting arbitrary-shaped hierarchical containers into a single (or &lsquo;flat&rsquo;) B+Tree.</p><h3 id=data-structure>Data structure<a href=#data-structure class=anchor aria-hidden=true>#</a></h3><p>Let for certainty we have the following Multimap: <code>{1=[1,5,2,4], 4=[7,3,1], 6=[5,9,1,2,0], 7=[8,1]}</code>. We represent is with <em>three</em> arrays: keys <code>K[]</code>, values <code>V[]</code> and <a href=/docs/data-zoo/searchable-seq/>searchable symbol sequence</a> <code>S[]</code>. <code>Srle[]</code> is an <a href=/docs/data-zoo/compressed-symbol-seq/>RLE encoding</a> for <code>S[]</code> (we need one <code>S[]</code> or <code>Srle[]</code>, <em>not</em> both):</p><figure><img src=multimap.svg></figure><p>The rule is simple. The keys vector <code>K[]</code> should be built in the increasing key order to use binary search for fast lookup. The values vector <code>V[]</code> should be built in the <em>key vector&rsquo;s order</em> by concatenating corresponding vectors.</p><p>The symbol sequence <code>S[]</code> is constructed in the following way. For each key in key&rsquo;s vector <code>K[]</code> we put <code>0</code> and for each value element in the <em>associated value&rsquo;s sub-vector</em> <code>V[]</code> we put <code>1</code> as it&rsquo;s shown at the picture above. We will be using <a href=/docs/data-zoo/searchable-seq/><code>rank()</code> and <code>select()</code></a> operations for implementing access and update operations over our Multimap.</p><p>To find a value for a key we first need to find a position for this key in the sorted vector <code>K[]</code> by using binary search: <code>Px = bsearch(S[], Kx)</code>. Given the position <code>Px</code> for key <code>Kx</code> we can find corresponding position <code>Sx</code> in the <code>S[]</code> by using the <code>select</code> operation: <code>Sx = select(S[], Px + 1, 0)</code> &ndash; we are looking for position of <code>Px</code>-th <code>0</code> in <code>S[]</code>. <code>Sx + 1</code> will be position of the first symbol <code>1</code> in <code>S[]</code>, corresponding to the first value, associated with <code>Kx</code>. In order to locate related position in <code>V[]</code> we need to calculate total size of all sub-vectors for keys <em>before</em> <code>Kx</code>: <code>Vx = rank(S[], Px, 1)</code>. In order to find number of elements in specific sub-vector, associated with <code>Kx</code> we can use <code>count()</code> operation &ndash; count number of symbols in a run, starting from the specified one: <code>Lx = count(S[], Px + 1, 1)</code> &ndash; counting number of <code>1</code> in <code>S[]</code> starting from <code>Px + 1</code> till we either hit the next <code>0</code> (next key&rsquo;s symbol mark in the sequence) or the end of the sequence.</p><p>By applying the same math we can derive corresponding operations for updating the Multimap structure: insert entries, remove entries, merge and split maps and so on. &lsquo;Rank()&rsquo;, &lsquo;select()&rsquo; and &lsquo;count()&rsquo; have logarithmic time complexity.</p><p>Spending one bit for every value element in the Multimap is not necessary. We can easily use RLE encoding <code>Srle[]</code> for <code>S[]</code> as it&rsquo;s shown at the picture above. For large value sub-vectors (file system/object store) space saving may be significant.</p><h3 id=representing-relational-tables>Representing relational tables<a href=#representing-relational-tables class=anchor aria-hidden=true>#</a></h3><p>Note that Multimap is sufficient for representing a row-wise <em>clustered</em> relational table. <code>K</code> is a table&rsquo;s <em>primary key</em> and corresponding sub-vector may contain row&rsquo;s content in an unstructured form. If we want unclustered (regular) table without a primary key, we just not needed the <code>K[]</code> vector: <code>std::vector&lt;std::vector&lt;V>></code>. Everything else is the same.</p><p>Such table representation has two notable properties:</p><ol><li><p>To <em>scan</em> a table we just need to scan three perfectly memory-aligned data structures concurrently.</p></li><li><p>Table may easily have <em>very large</em> rows, as well very small rows. There is no any intrinsic memory overhead for this.</p></li></ol><h2 id=multimap-with-searchable-values>Multimap with searchable values<a href=#multimap-with-searchable-values class=anchor aria-hidden=true>#</a></h2><p>Practically important case is <code>std::map&lt;K, std::set&lt;V>></code> or, here, SearchableMultimap used, for instance, for implementing sparse graphs. If <code>K</code> and <code>V</code> are graph node&rsquo;s identifiers, SearchableMultimap may be used for storing node&rsquo;s neighbours in the graph.</p><p>The easiest way to make sub-vectors efficiently searchable is just to sort them. And this is the only option if identifiers are not numbers. Because we know the size of sub-vector for a given key, we can binary-search in this sub-vector only.</p><p>The second option is to use the same technique that is used for <a href=/docs/data-zoo/partial-sum-tree/>partial sum trees</a>. If identifiers are numbers supporting <code>+</code> and <code>-</code> binary operations, we can build <em>delta sequences</em> for each sub-array individually and concatenate them into <code>V[]</code>. Unlike locally-sorted sub-vectors, such delta-sequence is globally-searchable. We just need to add <em>prefix</em> <code>Nx = sum(V[], Vx)</code> for key the <code>Kx</code> to the <code>Kx</code>&rsquo;s value.</p><h2 id=wide-table>Wide Table<a href=#wide-table class=anchor aria-hidden=true>#</a></h2><p><em>Wide Table</em> is a data structure of the form <code>std::map&lt;RKT, std::map&lt;CKT, std::vector&lt;V>>></code> where <code>RKT</code> is a row key type and <code>CKT</code> is a column key type. Each row of a Wide Table may have arbitrary, practically unlimited, number of columns. This is rarely needed in practice for <em>relational</em> tables. But may be needed for other <em>application-level</em> data structures built on top of wide tables. Basically, wide table is a sparse matrix or a sparse graph.</p><figure><img src=wide-table.svg></figure><p>It&rsquo;s rather easy to get wide table from a Multimap, we just need an alphabet with three symbols instead of two: <code>0</code> means row row key RK, <code>1</code> means column key CK and <code>2</code> means column data. Everything else, including navigational operations are basically the same.</p><h2 id=generalized-hierarchical-container>Generalized Hierarchical Container<a href=#generalized-hierarchical-container class=anchor aria-hidden=true>#</a></h2><p>The pattern above can be generalized. Single-level containers, like Map or Vector need a symbol sequence with zero-size alphabet (or no sequence at all). Each new layer add one symbol to the alphabet. Memoria relies heavily on this property for complex containers. For an L-level container we have L vectors and a searchable symbol sequence (so, L + 1 vectors total).</p><h2 id=multistream-btree>Multistream B+Tree.<a href=#multistream-btree class=anchor aria-hidden=true>#</a></h2><p>There are basically two strategies of implementing generalized hierarchical containers for external memory:</p><ol><li><em>One B+Tree per vector or sequence</em>. This is the easiest option because we just need two separately engineered B+Trees. There are two main drawbacks here. First, small structures may take up to <code>L + 1</code> blocks of memory. Second, for each query we need to search in multiple B+Trees (from root down to leafs).</li><li><em>Combine all vectors in one B+Tree</em>, enforcing locality principle: data accessed together shout be in the same block or very close to each other. It can make certain important queries faster, but by the expense of other types of queries.</li></ol><p>No strategy is universally the best, but the second one is better if we want to optimize things for <em>reading</em>. Memoria may use them both for different reasons, but it primarily relies on the second one &ndash; <em>multistream B+Tree</em>.</p><p>The basic idea is simple.</p><p>If we are representing a Multimap with a multistream B+Tree, we need to split <code>Srle[]</code>, <code>K[]</code> and <code>V[]</code> in such way that all related array elements be put into the same leaf node. In this case, for example, if we found specific key, associated values will be either in this leaf (most likely) or in the next one (pretty quick operation).</p><p>Branch node&rsquo;s structure is similar. We need one array for maximum keys for each child (Key Stream), and two arrays for sums of <code>0</code> and <code>1</code> in the subtree&rsquo;s <code>Srle</code> sequence (Srle Stream). And, of course, child node ID array:</p><figure><img src=multistream_tree_nodes.svg></figure><p>Branch nodes for <code>Srle</code> sequence form a <a href=/docs/data-zoo/partial-sum-tree/>partial/prefix sum tree</a>, that can be used for efficient implementation of &lsquo;rank()&rsquo; and &lsquo;select()&rsquo; operations.</p><p>Keys stream in this specific case may be searched in a usual way for max-type B+tree.</p><p>Note that in this example branch nodes do not show Value Stream, because values are not searchable, so we don&rsquo;t need to store separate <em>index</em> info for values.</p><p>Note also that mutistream B+Tree implementation in Memoria is slightly different in the way how streams are represented in tree blocks, here we omitted some details for brevity.</p><div class="docs-navigation d-flex justify-content-between"><a href=/docs/data-zoo/compressed-symbol-seq/><div class="card my-1"><div class="card-body py-2">&larr; Compressed Symbol Sequence</div></div></a><a class=ms-auto href=/docs/data-zoo/louds-tree/><div class="card my-1"><div class="card-body py-2">Level Order Unary Degree Sequence (LOUDS) &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Powered by <a href=https://www.github.com/>Github</a>, <a href=https://gohugo.io/>Hugo</a>, and <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-end"><ul class=list-inline><li class=list-inline-item><a href=/privacy-policy/>Privacy</a></li></ul></div></div></div></footer><script src=/js/bootstrap.min.73ca27033146a505b6a0f66b79d99f613a18e778bc9606fd223476d0ebf0fc10508b0d4f5c448b0a946fa1d71fbeffaae9732adc0c2890e61c449217fd6ee1c0.js integrity="sha512-c8onAzFGpQW2oPZredmfYToY53i8lgb9IjR20Ovw/BBQiw1PXESLCpRvodcfvv+q6XMq3AwokOYcRJIX/W7hwA==" crossorigin=anonymous defer></script>
<script src=/js/highlight.min.c5b6bb65307e087bfc3dd5a73cf000f3dc6a8b665db8c3fcbd62a3368e2f82ee494fd1ff5f025a09216cf6390bac7565c5469c6958caac1b9d09c85ba0adfefc.js integrity="sha512-xba7ZTB+CHv8PdWnPPAA89xqi2ZduMP8vWKjNo4vgu5JT9H/XwJaCSFs9jkLrHVlxUacaVjKrBudCchboK3+/A==" crossorigin=anonymous defer></script>
<script src=/js/vendor/katex/dist/katex.min.07c5862e6eea64c90e601fcaacaa0dbdb03f60dbbac68a5a5830130a00332df28001a5fa2375b739426606b441725db1af012c7e4b04b8fb222025cc0d2ac073.js integrity="sha512-B8WGLm7qZMkOYB/KrKoNvbA/YNu6xopaWDATCgAzLfKAAaX6I3W3OUJmBrRBcl2xrwEsfksEuPsiICXMDSrAcw==" crossorigin=anonymous defer></script>
<script src=/js/vendor/katex/dist/contrib/auto-render.min.bc779bab10cdc862f139e7cd6255a8f021bc483db2b7bc6d553238fb220e937dbe5cd511100d2ab764ee5d9f9092a2cdcc4e6ae109966efc18338f0b275d927d.js integrity="sha512-vHebqxDNyGLxOefNYlWo8CG8SD2yt7xtVTI4+yIOk32+XNUREA0qt2TuXZ+QkqLNzE5q4QmWbvwYM48LJ12SfQ==" crossorigin=anonymous defer></script>
<script src=/main.min.56cf146845ee56429c57a9bb74bee52540a1aa942a32506ad0d185db760f2f7a5d76f39cde824735c8b7e89f2e4453cc4da383eaa2c2a7d6a2c9dafd7061e74d.js integrity="sha512-Vs8UaEXuVkKcV6m7dL7lJUChqpQqMlBq0NGF23YPL3pddvOc3oJHNci36J8uRFPMTaOD6qLCp9aiydr9cGHnTQ==" crossorigin=anonymous defer></script>
<script src=https://memoria-framework.dev/index.min.3e2866774e56f832748c58ad2c9f69011ce3470dbe6e78d54aea32182b7b2a5fe26950a2001b0dc351b9e245a7f8beccced435c911455218e0a2e90e98f2dfb6.js integrity="sha512-Pihmd05W+DJ0jFitLJ9pARzjRw2+bnjVSuoyGCt7Kl/iaVCiABsNw1G54kWn+L7MztQ1yRFFUhjgoukOmPLftg==" crossorigin=anonymous defer></script></body></html>