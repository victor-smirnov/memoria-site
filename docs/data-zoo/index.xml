<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Containers List on</title><link>https://memoria-framework.dev/docs/data-zoo/</link><description>Recent content in Containers List on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 28 Oct 2021 02:07:01 -0400</lastBuildDate><atom:link href="https://memoria-framework.dev/docs/data-zoo/index.xml" rel="self" type="application/rss+xml"/><item><title>Containers Overview</title><link>https://memoria-framework.dev/docs/data-zoo/overview/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/overview/</guid><description/></item><item><title>Partial Sums Tree</title><link>https://memoria-framework.dev/docs/data-zoo/partial-sum-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/partial-sum-tree/</guid><description>Let&amp;rsquo;s take a sequence of monotonically increasing numbers, and get delta sequence from it, as it is shown on the following figure. Partial Sum Tree is a tree of sums over this delta sequence.
Packed tree in Memoria is a multiary balanced tree mapped to an array. For instance in a level order as it shown on the figure.
Given a sequence of N numbers with monotonically increasing values, partial sum tree provides several important operations:</description></item><item><title>Searchable Sequence</title><link>https://memoria-framework.dev/docs/data-zoo/searchable-seq/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/searchable-seq/</guid><description>Searchable sequence or rank/select dictionary is a sequence of symbols that supports two operations:
rank(position, symbol) is number of occurrences of symbol in the sequence in the range [0, position) select(rank, symbol) is a position of rank-th occurrence of the symbol in the sequence. Usually the alphabet is {0, 1} because of its practical importance, but larger alphabets are of significant interest too. Especially in Bioinformatics and Artificial Intelligence.</description></item><item><title>Level Order Unary Degree Sequence (LOUDS)</title><link>https://memoria-framework.dev/docs/data-zoo/louds-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/louds-tree/</guid><description>Level Order Unary Degree Sequence or LOUDS is a special form of ordered tree encoding. To get it we first need to enumerate all nodes of a tree in level order as it is shown of the following figure.
Then for each node we write its degree in unitary encoding. For example, degree of the fist node is 3, then its unitary encoding is &amp;lsquo;1110&amp;rsquo;. To finish LOUDS string we need to prepend substring &amp;lsquo;10&amp;rsquo; to it as it is shown on the figure.</description></item><item><title>Multiary Wavelet Trees</title><link>https://memoria-framework.dev/docs/data-zoo/wavelet-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/wavelet-tree/</guid><description>Wavelet trees (WT) are data succinct rank/select dictionaries for large alphabets with many practical applications. There is a good explanation of what binary wavelet trees are and how they work. They provide rank() and select() over symbol sequences ($N$ symbols) drawn from arbitrary fixed-size alphabets ($K$ symbols) in $O(log(N) * log(K))$ operations, where logarithms are on the base of 2. Therefore, for large alphabets, $log(K)$ is quite a big value that leads to big hidden constants in practical implementations of the binary WT.</description></item></channel></rss>