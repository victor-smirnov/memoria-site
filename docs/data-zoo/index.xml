<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Containers List on</title><link>https://memoria-framework.dev/docs/data-zoo/</link><description>Recent content in Containers List on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 28 Oct 2021 02:07:01 -0400</lastBuildDate><atom:link href="https://memoria-framework.dev/docs/data-zoo/index.xml" rel="self" type="application/rss+xml"/><item><title>Core Data Structures -- Overview</title><link>https://memoria-framework.dev/docs/data-zoo/overview/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/overview/</guid><description>This sections contans detailed description of some core data structures Memoria&amp;rsquo;s containers are based on.</description></item><item><title>Partial Sums Tree</title><link>https://memoria-framework.dev/docs/data-zoo/partial-sum-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/partial-sum-tree/</guid><description>Description Let&amp;rsquo;s take a sequence of monotonically increasing numbers, and get delta sequence from it, as it is shown on the following figure. Partial Sum Tree is a tree of sums over this delta sequence.
Packed tree in Memoria is a multiary balanced tree mapped to an array. For instance in a level order as it shown on the figure.
Given a sequence of N numbers with monotonically increasing values, partial sum tree provides several important operations:</description></item><item><title>Searchable Sequence</title><link>https://memoria-framework.dev/docs/data-zoo/searchable-seq/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/searchable-seq/</guid><description>Searchable sequence or rank/select dictionary is a sequence of symbols that supports two operations:
rank(position, symbol) is number of occurrences of symbol in the sequence in the range [0, position) select(rank, symbol) is a position of rank-th occurrence of the symbol in the sequence. Usually the alphabet is {0, 1} because of its practical importance, but larger alphabets are of significant interest too. Especially in Bioinformatics and Artificial Intelligence.</description></item><item><title>Compressed Symbol Sequence</title><link>https://memoria-framework.dev/docs/data-zoo/compressed-symbol-seq/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/compressed-symbol-seq/</guid><description>Compressed symbol sequence takes space proportional to the information contained in it, not to the number of symbols at the first place. It&amp;rsquo;s achievable via using special encoding and Memoria is using the simplest one &amp;ndash; run-length encoding (RLE). The basic idea is simple: symbol sequence is represented as a series of short repeatable patterns. The main challenge is how to encode parameters succinctly in the way that minimizes overhead for poorly compressible sequences.</description></item><item><title>Hierarchical Containers</title><link>https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/hierarchical-containers/</guid><description>In this page it&amp;rsquo;s explained how various hierarchical containers (vectors with large values, multimaps, tables, wide tables, etc) are organized inside and how searchable sequences make it possible.
Multimap Let, for simplicity, we have a multimap std::map&amp;lt;int64_t, std::vector&amp;lt;uint8_t&amp;gt;&amp;gt; (we call it a Multimap here) that is internally a binary search tree (RB-/AVL-tree etc) with vectors as values. Vector is internally a contiguous data structure but the search tree is basically a tree-shaped linked list or pointer chasing data structure.</description></item><item><title>Level Order Unary Degree Sequence (LOUDS)</title><link>https://memoria-framework.dev/docs/data-zoo/louds-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/louds-tree/</guid><description>Level Order Unary Degree Sequence or LOUDS is a special form of ordered tree encoding. To get it we first need to enumerate all nodes of a tree in level order as it is shown of the following figure.
Then for each node we write its degree in unitary encoding. For example, degree of the fist node is 3, then its unitary encoding is &amp;lsquo;1110&amp;rsquo;. To finish LOUDS string we need to prepend substring &amp;lsquo;10&amp;rsquo; to it as it is shown on the figure.</description></item><item><title>Multiary Wavelet Trees</title><link>https://memoria-framework.dev/docs/data-zoo/wavelet-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/wavelet-tree/</guid><description>Wavelet trees (WT) are data succinct rank/select dictionaries for large alphabets with many practical applications. There is a good explanation of what binary wavelet trees are and how they work. They provide rank() and select() over symbol sequences ($N$ symbols) drawn from arbitrary fixed-size alphabets ($K$ symbols) in $O(log(N) * log(K))$ operations, where logarithms are on the base of 2. Therefore, for large alphabets, $log(K)$ is quite a big value that leads to big hidden constants in practical implementations of the binary WT.</description></item><item><title>Packed Allocator</title><link>https://memoria-framework.dev/docs/data-zoo/packed-allocator/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/packed-allocator/</guid><description>We need to place several, possibly resizable (see below), objects into a single contiguous memory block of limited size. Classical malloc-like memory allocator is not suitable here because it doesn&amp;rsquo;t work well with resizable objects. Especially if they are allocated in a relatively small memory block. To maintain resizability efficiently we have to relocate other objects if some object is resized.
Resizable Object Pattern Resizable object is an object that has unbounded size.</description></item><item><title>Associative Memory (Part 1)</title><link>https://memoria-framework.dev/docs/data-zoo/associative-memory-1/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/associative-memory-1/</guid><description>What is Associative Memory Associative memory is content-addressable memory, where the item is being addressed given some part of it. In a broad sense, associative memory is a model for high-level mental function of Memory. Such level of complexity is by no means a simple thing for implementation, though artificial neural networks have demonstrated pretty impressive results (at scale). In this article we are scaling things down to the level of bits and showing how to design and implement content-addressable memory at the level of bits.</description></item><item><title>Associative Memory (Part 2)</title><link>https://memoria-framework.dev/docs/data-zoo/associative-memory-2/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/associative-memory-2/</guid><description>In the previous part we saw how LOUDS tree can be used for generic compact and efficient associative associative memory over arbitrary number of dimensions. In this part we will see how LOUDS trees can be used for function approximation and inversion.
Definitions Let $[0, 1] \in R$ is the domain and range we are operating on. $D$ is a number of dimensions of our space, and for the sake of visualizability, $D = 2$.</description></item></channel></rss>