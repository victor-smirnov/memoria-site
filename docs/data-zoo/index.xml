<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Containers List on</title><link>https://memoria-framework.dev/docs/data-zoo/</link><description>Recent content in Containers List on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 28 Oct 2021 02:07:01 -0400</lastBuildDate><atom:link href="https://memoria-framework.dev/docs/data-zoo/index.xml" rel="self" type="application/rss+xml"/><item><title>Core Data Structures -- Overview</title><link>https://memoria-framework.dev/docs/data-zoo/overview/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/overview/</guid><description>This sections contans detailed description of some core data structures Memoria&amp;rsquo;s containers are based on.</description></item><item><title>Partial Sums Tree</title><link>https://memoria-framework.dev/docs/data-zoo/partial-sum-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/partial-sum-tree/</guid><description>Description #
Let&amp;rsquo;s take a sequence of monotonically increasing numbers, and get delta sequence from it, as it is shown on the following figure. Partial Sum Tree is a tree of sums over this delta sequence.
Packed tree in Memoria is a multiary balanced tree mapped to an array. For instance in a level order as it shown on the figure.
Given a sequence of N numbers with monotonically increasing values, partial sum tree provides several important operations:</description></item><item><title>Searchable Sequence</title><link>https://memoria-framework.dev/docs/data-zoo/searchable-seq/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/searchable-seq/</guid><description>Searchable sequence or rank/select dictionary is a sequence of symbols that supports two operations:
rank(position, symbol) is number of occurrences of symbol in the sequence in the range [0, position) select(rank, symbol) is a position of rank-th occurrence of the symbol in the sequence. Usually the alphabet is {0, 1} because of its practical importance, but larger alphabets are of significant interest too. Especially in Bioinformatics and Artificial Intelligence.
There are many implementations of binary searchable sequences (bitmaps) providing fast query operations with $O(1)$ time complexity.</description></item><item><title>Compressed Symbol Sequence</title><link>https://memoria-framework.dev/docs/data-zoo/compressed-symbol-seq/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/compressed-symbol-seq/</guid><description>TBC</description></item><item><title>Hierarchical Table</title><link>https://memoria-framework.dev/docs/data-zoo/hierarchical-table/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/hierarchical-table/</guid><description>TBC</description></item><item><title>Level Order Unary Degree Sequence (LOUDS)</title><link>https://memoria-framework.dev/docs/data-zoo/louds-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/louds-tree/</guid><description>Level Order Unary Degree Sequence or LOUDS is a special form of ordered tree encoding. To get it we first need to enumerate all nodes of a tree in level order as it is shown of the following figure.
Then for each node we write its degree in unitary encoding. For example, degree of the fist node is 3, then its unitary encoding is &amp;lsquo;1110&amp;rsquo;. To finish LOUDS string we need to prepend substring &amp;lsquo;10&amp;rsquo; to it as it is shown on the figure.</description></item><item><title>Multiary Wavelet Trees</title><link>https://memoria-framework.dev/docs/data-zoo/wavelet-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/wavelet-tree/</guid><description>Wavelet trees (WT) are data succinct rank/select dictionaries for large alphabets with many practical applications. There is a good explanation of what binary wavelet trees are and how they work. They provide rank() and select() over symbol sequences ($N$ symbols) drawn from arbitrary fixed-size alphabets ($K$ symbols) in $O(log(N) * log(K))$ operations, where logarithms are on the base of 2. Therefore, for large alphabets, $log(K)$ is quite a big value that leads to big hidden constants in practical implementations of the binary WT.</description></item><item><title>Mutistream Balanced Tree</title><link>https://memoria-framework.dev/docs/data-zoo/mutistream-tree/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/mutistream-tree/</guid><description>The Problem #
Let us consider data structure mapping an integer ID to a dynamic vector. Nothing complicated is here but there is one requirement: it has to represent small data values compactly, without that overhead most file systems have. That means we can&amp;rsquo;t just use Map&amp;lt;ID, Vector&amp;lt;&amp;gt;&amp;gt; because like any other container, even empty Vector&amp;lt;&amp;gt; consumes at least one memory block. So this overhead will be very significant for large number of small data values.</description></item><item><title>Packed Allocator</title><link>https://memoria-framework.dev/docs/data-zoo/packed-allocator/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/packed-allocator/</guid><description>We need to place several, possibly resizable (see below), objects into a single contiguous memory block of limited size. Classical malloc-like memory allocator is not suitable here because it doesn&amp;rsquo;t work well with resizable objects. Especially if they are allocated in a relatively small memory block. To maintain resizability efficiently we have to relocate other objects if some object is resized.
Resizable Object Pattern #
Resizable object is an object that has unbounded size.</description></item><item><title>Associative Memory (Part 1)</title><link>https://memoria-framework.dev/docs/data-zoo/associative-memory-1/</link><pubDate>Thu, 28 Oct 2021 02:07:01 -0400</pubDate><guid>https://memoria-framework.dev/docs/data-zoo/associative-memory-1/</guid><description>What is Associative Memory #
Associative memory is content-addressable memory, where the item is being addressed given some part of it. In a broad sense, associative memory is a model for high-level mental function of Memory. Such level of complexity is by no means a simple thing for implementation, though artificial neural networks have demonstrated pretty impressive results (at scale). In this article we are scaling things down to the level of bits and showing how to design and implement content-addressable memory at the level of bits.</description></item></channel></rss>