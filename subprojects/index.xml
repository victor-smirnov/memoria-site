<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>List of Subprojects on</title><link>https://memoria-framework.dev/subprojects/</link><description>Recent content in List of Subprojects on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:49:55 +0000</lastBuildDate><atom:link href="https://memoria-framework.dev/subprojects/index.xml" rel="self" type="application/rss+xml"/><item><title>Subprojects Overview</title><link>https://memoria-framework.dev/subprojects/overview/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/overview/</guid><description>Memoria Framework may have some self-sufficient parts with a perspective to graduate into standalone projects. Organizationally, they can be either separate repositories or reside in the same repository as Memoria itself.</description></item><item><title>Smart Storage</title><link>https://memoria-framework.dev/subprojects/smart-storage/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/smart-storage/</guid><description>One of the most complex problems in memory architectures is how to handle loss of power. For applications working with persistent memory, this problem is reducing to the procedure of atomic dumping of the state from volatile memory to a non-volatile memory. Even if the main memory is non-volatile, after power is restored, the entire system is in unknown state. Because power loss may occur in-between a long series of no-atomic memory updates.</description></item><item><title>SwimmerDB</title><link>https://memoria-framework.dev/subprojects/swimmer-db/</link><pubDate>Tue, 06 Oct 2020 08:49:55 +0000</pubDate><guid>https://memoria-framework.dev/subprojects/swimmer-db/</guid><description>Introduction #
SwimmerDB is a classical client/server and embedded database built on top of the SWMRStore (pronounced &amp;ldquo;swimmer-store&amp;rdquo;). It can also be used together with FUSE Integration to export structures data as a filesystem for certain applications.
The main purpose of SwimmerDB is to showcase Memoria&amp;rsquo;s capabilities as a full stack data engineering framework, so it&amp;rsquo;s not being targeted as a database for specific types of applications like OLTP or analytics.</description></item><item><title>Accelerated RISC-V Core for Memoria</title><link>https://memoria-framework.dev/subprojects/risc-v-core/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/risc-v-core/</guid><description/></item><item><title>FUSE Integration</title><link>https://memoria-framework.dev/subprojects/fuse-integration/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/fuse-integration/</guid><description/></item><item><title>Jenny Metaprogramming Platform</title><link>https://memoria-framework.dev/subprojects/jenny-platform/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/jenny-platform/</guid><description>See Why C++ document for introduction.
Better C++ #
C++ TMP, though pretty powerful, has its fundamental limitations. The following is the list of the most annoying ones. They are not about the language itself, but the productivity of the language in a programming-in-large context.
Template metaprograms can&amp;rsquo;t do any IO, so any input data structures must be represented as lists of types (and plain arrays of literal types). There is no convenient way to apply schema to a, for instance, hierarchical data.</description></item></channel></rss>