<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>List of Subprojects on</title><link>https://memoria-framework.dev/subprojects/</link><description>Recent content in List of Subprojects on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:49:55 +0000</lastBuildDate><atom:link href="https://memoria-framework.dev/subprojects/index.xml" rel="self" type="application/rss+xml"/><item><title>Subprojects Overview</title><link>https://memoria-framework.dev/subprojects/overview/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/overview/</guid><description>Memoria Framework may have some self-sufficient parts with a perspective to graduate into standalone projects. Organizationally, they can be either separate repositories or reside in the same repository as Memoria itself.</description></item><item><title>Smart Storage</title><link>https://memoria-framework.dev/subprojects/smart-storage/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/smart-storage/</guid><description>One of the most complex problems in memory architectures is how to handle loss of power. For applications working with persistent memory, this problem is reducing to the procedure of atomic dumping of the state from volatile memory to a non-volatile memory. Even if the main memory is non-volatile, after power is restored, the entire system is in unknown state. Because power loss may occur in-between a long series of no-atomic memory updates.</description></item><item><title>SwimmerDB</title><link>https://memoria-framework.dev/subprojects/swimmer-db/</link><pubDate>Tue, 06 Oct 2020 08:49:55 +0000</pubDate><guid>https://memoria-framework.dev/subprojects/swimmer-db/</guid><description>Introduction SwimmerDB is a classical client/server and embedded database built on top of the SWMRStore (pronounced &amp;ldquo;swimmer-store&amp;rdquo;). It can also be used together with FUSE Integration to export structures data as a filesystem for certain applications.
The main purpose of SwimmerDB is to showcase Memoria&amp;rsquo;s capabilities as a full stack data engineering framework, so it&amp;rsquo;s not being targeted as a database for specific types of applications like OLTP or analytics. Instead, SwimmerDB will be good where its underlying storage engine is good.</description></item><item><title>Accelerated RISC-V Core for Memoria</title><link>https://memoria-framework.dev/subprojects/risc-v-core/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/risc-v-core/</guid><description/></item><item><title>FUSE Integration</title><link>https://memoria-framework.dev/subprojects/fuse-integration/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/fuse-integration/</guid><description/></item><item><title>Jenny Metaprogramming Platform</title><link>https://memoria-framework.dev/subprojects/jenny-platform/</link><pubDate>Thu, 28 Oct 2021 02:06:54 -0400</pubDate><guid>https://memoria-framework.dev/subprojects/jenny-platform/</guid><description>Memoria is using C++ as its main development language and it&amp;rsquo;s a deliberate decision. This document explains what C++ gives to data platforms and how optimal language and run-time environment might look like.
From set-theoretic perspective there are much more data structures than algorithms, this is the reason why generic programming (GP) support is important for any modern programming language. The same linear search algorithm can be applied to the great variety of physical data layouts and types.</description></item></channel></rss>